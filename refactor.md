ğŸ§‘â€ğŸ’» ## USER

This is the Gemini CLI. We are setting up the context for our chat.
Today's date is 2025å¹´12æœˆ9æ—¥ç«æ›œæ—¥ (formatted according to the user's locale).
My operating system is: win32
The project's temporary directory is: C:\Users\sasor\.gemini\tmp\82031129ddf8c2b29defcc5c8af0d31d8bfb01c35601732baed7c8dd33112a72
I'm currently working in the directory: C:\Users\sasor\Gitworks\MPro-Town-Planning
Here is the folder structure of the current working directories:

Showing up to 200 items (files + folders). Folders or files indicated with ... contain more items not shown, were ignored, or the display limit (200 items) was reached.

C:\Users\sasor\Gitworks\MPro-Town-Planning\
â”œâ”€â”€â”€.gitattributes
â”œâ”€â”€â”€.gitignore
â”œâ”€â”€â”€gradle.properties
â”œâ”€â”€â”€gradlew
â”œâ”€â”€â”€gradlew.bat
â”œâ”€â”€â”€README.md
â”œâ”€â”€â”€settings.gradle.kts
â”œâ”€â”€â”€.git\...
â”œâ”€â”€â”€.github\
â”‚   â””â”€â”€â”€workflows\
â”‚       â””â”€â”€â”€gradle.yml
â”œâ”€â”€â”€.gradle\...
â”œâ”€â”€â”€.settings\
â”œâ”€â”€â”€app\
â”‚   â”œâ”€â”€â”€build.gradle.kts
â”‚   â”œâ”€â”€â”€.settings\
â”‚   â”‚   â””â”€â”€â”€org.eclipse.buildship.core.prefs
â”‚   â”œâ”€â”€â”€bin\
â”‚   â”‚   â”œâ”€â”€â”€main\
â”‚   â”‚   â”‚   â”œâ”€â”€â”€.gitkeep
â”‚   â”‚   â”‚   â”œâ”€â”€â”€images\
â”‚   â”‚   â”‚   â”‚   â””â”€â”€â”€dummy.png
â”‚   â”‚   â”‚   â””â”€â”€â”€io\
â”‚   â”‚   â”‚       â””â”€â”€â”€github\
â”‚   â”‚   â”‚           â””â”€â”€â”€sasori_256\
â”‚   â”‚   â”‚               â””â”€â”€â”€town_planning\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€app\
â”‚   â”‚   â”‚                   â”‚   â””â”€â”€â”€src\
â”‚   â”‚   â”‚                   â”‚       â””â”€â”€â”€main\
â”‚   â”‚   â”‚                   â”‚           â””â”€â”€â”€java\
â”‚   â”‚   â”‚                   â”‚               â””â”€â”€â”€io\
â”‚   â”‚   â”‚                   â”‚                   â””â”€â”€â”€github\
â”‚   â”‚   â”‚                   â”‚                       â””â”€â”€â”€sasori_256\
â”‚   â”‚   â”‚                   â”‚                           â””â”€â”€â”€town_planning\
â”‚   â”‚   â”‚                   â”‚                               â””â”€â”€â”€core\
â”‚   â”‚   â”‚                   â”‚                                   â””â”€â”€â”€strategy\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€controller\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€core\
â”‚   â”‚   â”‚                   â”‚   â””â”€â”€â”€strategy\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€event\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€model\
â”‚   â”‚   â”‚                   â”‚   â””â”€â”€â”€strategy\
â”‚   â”‚   â”‚                   â”œâ”€â”€â”€util\
â”‚   â”‚   â”‚                   â””â”€â”€â”€view\
â”‚   â”‚   â””â”€â”€â”€test\
â”‚   â”‚       â”œâ”€â”€â”€.gitkeep
â”‚   â”‚       â””â”€â”€â”€io\
â”‚   â”‚           â””â”€â”€â”€github\
â”‚   â”‚               â””â”€â”€â”€sasori_256\
â”‚   â”‚                   â””â”€â”€â”€town_planning\
â”‚   â”œâ”€â”€â”€build\...
â”‚   â””â”€â”€â”€src\
â”‚       â”œâ”€â”€â”€main\
â”‚       â”‚   â”œâ”€â”€â”€java\
â”‚       â”‚   â”‚   â””â”€â”€â”€io\
â”‚       â”‚   â”‚       â””â”€â”€â”€github\
â”‚       â”‚   â”‚           â””â”€â”€â”€sasori_256\
â”‚       â”‚   â”‚               â””â”€â”€â”€town_planning\
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€App.java
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€app\
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€src\
â”‚       â”‚   â”‚                   â”‚       â””â”€â”€â”€main\
â”‚       â”‚   â”‚                   â”‚           â””â”€â”€â”€java\
â”‚       â”‚   â”‚                   â”‚               â””â”€â”€â”€io\
â”‚       â”‚   â”‚                   â”‚                   â””â”€â”€â”€github\
â”‚       â”‚   â”‚                   â”‚                       â””â”€â”€â”€sasori_256\
â”‚       â”‚   â”‚                   â”‚                           â””â”€â”€â”€town_planning\
â”‚       â”‚   â”‚                   â”‚                               â””â”€â”€â”€core\
â”‚       â”‚   â”‚                   â”‚                                   â””â”€â”€â”€strategy\
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€controller\
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameController.java
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€KeyInputHandler.java
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€core\
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameContext.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameEntity.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameLoop.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameObject.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€Renderable.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€Terrain.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€Updatable.java
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€strategy\
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€RenderStrategy.java
â”‚       â”‚   â”‚                   â”‚       â””â”€â”€â”€UpdateStrategy.java
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€event\
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€EventBus.java
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€EventType.java
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€model\
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€BuildingType.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€DisasterType.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameMap.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€GameModel.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€MapCell.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€ResidentAttributes.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€ResidentType.java
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€TerrainType.java
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€strategy\
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€CompositeUpdateStrategy.java
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€MeteorDisasterStrategy.java
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€PopulationGrowthStrategy.java
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€RandomMoveStrategy.java
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€ResidentLifeCycleStrategy.java
â”‚       â”‚   â”‚                   â”‚       â”œâ”€â”€â”€ResidentRenderStrategy.java
â”‚       â”‚   â”‚                   â”‚       â””â”€â”€â”€SimpleRenderStrategy.java
â”‚       â”‚   â”‚                   â”œâ”€â”€â”€util\
â”‚       â”‚   â”‚                   â”‚   â”œâ”€â”€â”€Constants.java
â”‚       â”‚   â”‚                   â”‚   â””â”€â”€â”€ResourceLoader.java
â”‚       â”‚   â”‚                   â””â”€â”€â”€view\
â”‚       â”‚   â”‚                       â””â”€â”€â”€GameWindow.java
â”‚       â”‚   â””â”€â”€â”€resources\
â”‚       â”‚       â”œâ”€â”€â”€.gitkeep
â”‚       â”‚       â””â”€â”€â”€images\
â”‚       â”‚           â””â”€â”€â”€dummy.png
â”‚       â””â”€â”€â”€test\
â”‚           â”œâ”€â”€â”€java\
â”‚           â”‚   â””â”€â”€â”€io\
â”‚           â”‚       â””â”€â”€â”€github\
â”‚           â”‚           â””â”€â”€â”€sasori_256\
â”‚           â”‚               â””â”€â”€â”€town_planning\
â”‚           â”‚                   â””â”€â”€â”€AppTest.java
â”‚           â””â”€â”€â”€resources\
â”‚               â””â”€â”€â”€.gitkeep
â”œâ”€â”€â”€build\...
â””â”€â”€â”€gradle\
    â”œâ”€â”€â”€libs.versions.toml
    â””â”€â”€â”€wrapper\
        â”œâ”€â”€â”€gradle-wrapper.jar
        â””â”€â”€â”€gradle-wrapper.properties

Reminder: Do not return an empty response when a tool call is required.

My setup is complete. I will provide my first command in the next turn.

---

ğŸ§‘â€ğŸ’» ## USER


You are an AI agent that brings the power of Gemini directly into the terminal. Your task is to analyze the current directory and generate a comprehensive GEMINI.md file to be used as instructional context for future interactions.

**Analysis Process:**

1.  **Initial Exploration:**
    *   Start by listing the files and directories to get a high-level overview of the structure.
    *   Read the README file (e.g., `README.md`, `README.txt`) if it exists. This is often the best place to start.

2.  **Iterative Deep Dive (up to 10 files):**
    *   Based on your initial findings, select a few files that seem most important (e.g., configuration files, main source files, documentation).
    *   Read them. As you learn more, refine your understanding and decide which files to read next. You don't need to decide all 10 files at once. Let your discoveries guide your exploration.

3.  **Identify Project Type:**
    *   **Code Project:** Look for clues like `package.json`, `requirements.txt`, `pom.xml`, `go.mod`, `Cargo.toml`, `build.gradle`, or a `src` directory. If you find them, this is likely a software project.
    *   **Non-Code Project:** If you don't find code-related files, this might be a directory for documentation, research papers, notes, or something else.

**GEMINI.md Content Generation:**

**For a Code Project:**

*   **Project Overview:** Write a clear and concise summary of the project's purpose, main technologies, and architecture.
*   **Building and Running:** Document the key commands for building, running, and testing the project. Infer these from the files you've read (e.g., `scripts` in `package.json`, `Makefile`, etc.). If you can't find explicit commands, provide a placeholder with a TODO.
*   **Development Conventions:** Describe any coding styles, testing practices, or contribution guidelines you can infer from the codebase.

**For a Non-Code Project:**

*   **Directory Overview:** Describe the purpose and contents of the directory. What is it for? What kind of information does it hold?
*   **Key Files:** List the most important files and briefly explain what they contain.
*   **Usage:** Explain how the contents of this directory are intended to be used.

**Final Output:**

Write the complete content to the `GEMINI.md` file. The output must be well-formatted Markdown.


---

âœ¨ ## MODEL

**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "README.md"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "app/build.gradle.kts"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "settings.gradle.kts"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "app/src/main/java/io/github/sasori_256/town_planning/App.java"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "app/src/main/java/io/github/sasori_256/town_planning/core/GameLoop.java"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "app/src/main/java/io/github/sasori_256/town_planning/model/GameModel.java"
  }
}
```

---

ğŸ§‘â€ğŸ’» ## USER

**Tool Response**:
```json
{
  "id": "read_file-1765259884162-1fe25ca491751",
  "name": "read_file",
  "response": {
    "output": "# MPro-Town-Planning\r\nç¥ã®è¡—ã¥ãã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ \r\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1765259884163-8df1f688e36cc",
  "name": "read_file",
  "response": {
    "output": "/*\r\n * This file was generated by the Gradle 'init' task.\r\n *\r\n * This generated file contains a sample Java application project to get you started.\r\n * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/9.2.0/userguide/building_java_projects.html in the Gradle documentation.\r\n */\r\n\r\nplugins {\r\n    // Apply the application plugin to add support for building a CLI application in Java.\r\n    application\r\n}\r\n\r\nrepositories {\r\n    // Use Maven Central for resolving dependencies.\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    // Use JUnit Jupiter for testing.\r\n    testImplementation(libs.junit.jupiter)\r\n\r\n    testRuntimeOnly(\"org.junit.platform:junit-platform-launcher\")\r\n\r\n    // This dependency is used by the application.\r\n    implementation(libs.guava)\r\n}\r\n\r\n// Apply a specific Java toolchain to ease working on different environments.\r\njava {\r\n    toolchain {\r\n        languageVersion = JavaLanguageVersion.of(25)\r\n    }\r\n}\r\n\r\napplication {\r\n    // Define the main class for the application.\r\n    mainClass = \"io.github.sasori_256.town_planning.App\"\r\n}\r\n\r\ntasks.named<Test>(\"test\") {\r\n    // Use JUnit Platform for unit tests.\r\n    useJUnitPlatform()\r\n}\r\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1765259884164-d3781082d7e7",
  "name": "read_file",
  "response": {
    "output": "/*\r\n * This file was generated by the Gradle 'init' task.\r\n *\r\n * The settings file is used to specify which projects to include in your build.\r\n * For more detailed information on multi-project builds, please refer to https://docs.gradle.org/9.2.0/userguide/multi_project_builds.html in the Gradle documentation.\r\n */\r\n\r\nplugins {\r\n    // Apply the foojay-resolver plugin to allow automatic download of JDKs\r\n    id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"1.0.0\"\r\n}\r\n\r\nrootProject.name = \"MPro-Town-Planning\"\r\ninclude(\"app\")\r\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1765259884164-58cf500c8d32e",
  "name": "read_file",
  "response": {
    "output": "/*\r\n * This source file was generated by the Gradle 'init' task\r\n */\r\npackage io.github.sasori_256.town_planning;\r\n\r\npublic class App {\r\n    public String getGreeting() {\r\n        return \"Hello World!\";\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(new App().getGreeting());\r\n    }\r\n}\r\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1765259884429-2eab954a39201",
  "name": "read_file",
  "response": {
    "output": "package io.github.sasori_256.town_planning.core;\n\n// AtomicBooleanã«ã¤ã„ã¦\n// AtomicBooleanã¯ã€Javaã®java.util.concurrent.atomicãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å±ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€\n// ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªãƒ–ãƒ¼ãƒ«å€¤ã®æ“ä½œã‚’æä¾›ã—ã¾ã™ã€‚\n// è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ–ãƒ¼ãƒ«å€¤ã‚’æ‰±ã†éš›ã«ä½¿ç”¨ã•ã‚Œã€\n// ç«¶åˆçŠ¶æ…‹ã‚’é˜²ããŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚\n// AtomicBooleanã¯ã€åŸºæœ¬çš„ãªãƒ–ãƒ¼ãƒ«å€¤ã®æ“ä½œï¼ˆtrue/falseã®è¨­å®šã€å–å¾—ã€åè»¢ãªã©ï¼‰ã‚’\n// åŸå­æ“ä½œã¨ã—ã¦æä¾›ã—ã¾ã™ã€‚\n// ã“ã‚Œã«ã‚ˆã‚Šã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«å€¤ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã§ã‚‚ã€ä¸€è²«æ€§ãŒä¿ãŸã‚Œã¾ã™ã€‚\n// ä¾‹ãˆã°ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã¾ãŸã¯ã‚¯ãƒªã‚¢ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã«ã€\n// AtomicBooleanã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ç«¶åˆçŠ¶æ…‹ã‚’é˜²ãã€æ­£ã—ã„çµæœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n/**\n * å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã®ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æä¾›ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚\n * æ›´æ–°å‡¦ç†(Update)ã¨æç”»å‡¦ç†(Render)ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚\n */\npublic class GameLoop implements Runnable {\n  private final AtomicBoolean running = new AtomicBoolean(false);\n  private final Runnable updateCallback;\n  private final Runnable renderCallback;\n  private Thread thread = null;\n\n  // 60 FPS target\n  // TODO: ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’å®šæ•°åŒ–ã—ã¦å¤–éƒ¨ã‹ã‚‰å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹\n  private static final double TIME_STEP = 1.0 / 60.0;\n  private static final long TIME_STEP_NANO = (long) (TIME_STEP * 1_000_000_000);\n\n  public GameLoop(Runnable updateCallback, Runnable renderCallback) {\n    this.updateCallback = updateCallback;\n    this.renderCallback = renderCallback;\n  }\n\n  public void start() {\n    if (thread == null) {\n      try {\n        if (running.compareAndSet(false, true)) {\n          thread = new Thread(this, \"GameLoop-Thread\");\n          thread.setDaemon(true); // ã‚¢ãƒ—ãƒªçµ‚äº†æ™‚ã«è‡ªå‹•ã§è½ã¡ã‚‹ã‚ˆã†ã«\n          thread.start();\n        }\n      } catch (Exception e) {\n        running.set(false);\n        e.printStackTrace();\n      }\n    }\n  }\n\n  public void stop() {\n    running.set(false);\n    try {\n      if (thread != null) {\n        thread.join(); // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…æ©Ÿ\n      }\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      e.printStackTrace();\n    }\n  }\n\n  @Override\n  public void run() {\n    long lastTime = System.nanoTime(); // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»\n    double accumulator = 0.0; // çµŒéæ™‚é–“\n\n    while (running.get()) {\n      long now = System.nanoTime();\n      long frameTime = now - lastTime;\n      lastTime = now;\n\n      // ã‚ã¾ã‚Šã«å¤§ããªé…å»¶ãŒç™ºç”Ÿã—ãŸå ´åˆã®è£œæ­£\n      // ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ãŒ0.25ç§’ã‚’è¶…ãˆã‚‹å ´åˆã€0.25ç§’ã«åˆ¶é™ã™ã‚‹\n      if (frameTime > 250_000_000) { // Max frame time to avoid spiral of death (0.25s)\n        frameTime = 250_000_000;\n      }\n\n      accumulator += frameTime;\n\n      // ä¿®æ­£ãƒ«ãƒ¼ãƒ—: å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã§æ›´æ–°ã‚’è¡Œã†\n      while (accumulator >= TIME_STEP_NANO) {\n        updateCallback.run();\n        accumulator -= TIME_STEP_NANO;\n      }\n\n      // æç”»å‡¦ç†\n      renderCallback.run();\n\n      // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡: æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¾ã§å¾…æ©Ÿ\n      long sleepTime = (TIME_STEP_NANO - (System.nanoTime() - now)) / 1_000_000;\n      if (sleepTime > 1) {\n        try {\n          Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n}\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1765259884451-4ee65a7105481",
  "name": "read_file",
  "response": {
    "output": "package io.github.sasori_256.town_planning.model;\n\nimport io.github.sasori_256.town_planning.core.*;\nimport io.github.sasori_256.town_planning.event.*;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.stream.Stream;\n\n/**\n * ã‚²ãƒ¼ãƒ ã®å…¨ä½“ãƒ¢ãƒ‡ãƒ«ã€‚\n * GameContextã®å®Ÿè£…ã§ã‚ã‚Šã€GameLoopã®ãƒ›ã‚¹ãƒˆã§ã‚‚ã‚ã‚‹ã€‚\n */\npublic class GameModel implements GameContext, Updatable {\n  private final EventBus eventBus;\n  private final GameMap gameMap;\n  private final GameLoop gameLoop;\n\n  // ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ï¼ˆæ›´æ–°ã‚¹ãƒ¬ãƒƒãƒ‰ã¨æç”»ã‚¹ãƒ¬ãƒƒãƒ‰/UIã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã‚ã‚‹ãŸã‚ï¼‰\n  private final List<GameObject> entities = new CopyOnWriteArrayList<>();\n\n  private int souls = 100;\n  private int day = 1;\n  private double dayTimer = 0;\n  private static final double DAY_LENGTH = 10.0; // 10ç§’ã§1æ—¥\n\n  private double lastDeltaTime = 0;\n\n  public GameModel(EventBus eventBus) {\n\n    this.eventBus = eventBus;\n\n    // ãƒãƒƒãƒ—ã‚µã‚¤ã‚º 100x100 (ä»®)\n\n    this.gameMap = new GameMap(100, 100, eventBus);\n\n    // Event Subscriptions\n\n    this.eventBus.subscribe(EventType.SOUL_HARVESTED, data -> {\n\n      if (data instanceof Integer) {\n\n        addSouls((Integer) data);\n\n      }\n\n    });\n\n    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—\n\n    // Updateã¯this.tick()ã€Renderã¯Viewå´ã§è¡Œã†ãŒã€\n    // GameLoopã¯Runnableã‚’å—ã‘å–ã‚‹ã®ã§ã€Viewã¸ã®é€šçŸ¥ã¯EventBusçµŒç”±ã‹Callbackã§è¡Œã†å¿…è¦ãŒã‚ã‚‹ã€‚\n    // ä»Šå›ã¯å˜ç´”åŒ–ã®ãŸã‚ã€GameModelã¯Updateã®ã¿ã‚’ãƒ«ãƒ¼ãƒ—ã§å›ã—ã€Renderæ›´æ–°é€šçŸ¥ã‚’EventBusã§æŠ•ã’ã‚‹å½¢ã«ã™ã‚‹ã‹ã€\n    // ã‚ã‚‹ã„ã¯ViewãŒGameLoopã®RenderCallbackã‚’ç™»éŒ²ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚\n    // ã“ã“ã§ã¯ã€GameModelãŒãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†ã—ã€Viewæ›´æ–°ç”¨Callbackã‚’å—ã‘å–ã‚Œã‚‹ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã€‚\n\n    this.gameLoop = new GameLoop(this::tick, () -> {\n      // Render Trigger (Viewå´ã§è³¼èª­ã™ã‚‹ã‹ã€å°‚ç”¨ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‘¼ã¶)\n      // ä»Šå›ã¯EventBusã ã¨é«˜é »åº¦ã™ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ä¸€æ—¦ä¿ç•™ã€‚\n      // é€šå¸¸ã€Viewã¯ repaint() ã‚’å‘¼ã³å‡ºã™ Runnable ã‚’æ¸¡ã™ã€‚\n    });\n  }\n\n  public void startGameLoop(Runnable renderCallback) {\n    // æ—¢å­˜ã®ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚Šç›´ã™å¿…è¦ãŒã‚ã‚‹ï¼ˆRenderCallbackã‚’æ³¨å…¥ã™ã‚‹ãŸã‚ï¼‰\n    // ã¾ãŸã¯GameLoopã‚’å°‘ã—æ”¹é€ ã—ã¦setterã‚’ã¤ã‘ã‚‹ã€‚\n    // ã“ã“ã§ã¯æ–°ã—ã„GameLoopã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ç°¡æ˜“å®Ÿè£…ã€‚\n    GameLoop loop = new GameLoop(this::tick, renderCallback);\n    loop.start();\n  }\n\n  @Override\n  public void tick() {\n    // æ™‚é–“è¨ˆæ¸¬ (ç°¡æ˜“çš„)\n    double dt = 1.0 / 60.0; // Fixed time step\n    this.lastDeltaTime = dt;\n\n    // æ™‚é–“çµŒéå‡¦ç†\n    dayTimer += dt;\n    if (dayTimer >= DAY_LENGTH) {\n      dayTimer = 0;\n      day++;\n      eventBus.publish(EventType.DAY_PASSED, day);\n    }\n\n    // å…¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®æ›´æ–°\n    for (GameObject entity : entities) {\n      entity.update(this);\n    }\n  }\n\n  // --- GameContext Implementation ---\n\n  @Override\n  public EventBus getEventBus() {\n    return eventBus;\n  }\n\n  @Override\n  public GameMap getMap() {\n    return gameMap;\n  }\n\n  @Override\n  public Stream<GameObject> getEntities() {\n    return entities.stream();\n  }\n\n  @Override\n  public double getDeltaTime() {\n    return lastDeltaTime;\n  }\n\n  @Override\n  public void spawnEntity(GameObject entity) {\n    addEntity(entity);\n  }\n\n  @Override\n  public void destroyEntity(GameObject entity) {\n    removeEntity(entity);\n  }\n\n  // --- Game Logic API ---\n\n  public void addEntity(GameObject entity) {\n    entities.add(entity);\n    eventBus.publish(EventType.MAP_UPDATED, entity.getPosition());\n  }\n\n  public void removeEntity(GameObject entity) {\n    entities.remove(entity);\n    // ãƒãƒƒãƒ—ä¸Šã®å æœ‰æƒ…å ±ãªã©ã‚‚ã‚¯ãƒªã‚¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰MapçµŒç”±ã§è¡Œã†\n    eventBus.publish(EventType.MAP_UPDATED, entity.getPosition());\n  }\n\n  public int getSouls() {\n    return souls;\n  }\n\n  public void addSouls(int amount) {\n\n    this.souls += amount;\n\n    eventBus.publish(EventType.SOUL_CHANGED, souls);\n\n  }\n\n  /**\n   * \n   * æŒ‡å®šåº§æ¨™ä»˜è¿‘ã®æ­»ä½“ã‹ã‚‰é­‚ã‚’åˆˆã‚Šå–ã‚‹ã€‚\n   * \n   * @param pos ã‚¯ãƒªãƒƒã‚¯åº§æ¨™\n   * \n   * @return åˆˆã‚Šå–ã‚Šã«æˆåŠŸã—ãŸã‚‰true\n   * \n   */\n\n  public boolean harvestSoulAt(java.awt.geom.Point2D pos) {\n\n    double harvestRadius = 1.0; // åŠå¾„1ã‚°ãƒªãƒƒãƒ‰\n\n    // ç¯„å›²å†…ã®æ­»ä½“ã‚’æ¢ã™\n\n    // Note: è¤‡æ•°ã®æ­»ä½“ãŒé‡ãªã£ã¦ã„ã‚‹å ´åˆã€1ã¤ã ã‘å›åã™ã‚‹ã‹å…¨éƒ¨å›åã™ã‚‹ã‹ã¯ä»•æ§˜æ¬¡ç¬¬ã€‚\n\n    // ã“ã“ã§ã¯æœ€åˆã«è¦‹ã¤ã‹ã£ãŸ1ã¤ã‚’å›åã™ã‚‹ã€‚\n\n    java.util.Optional<GameObject> target = entities.stream()\n\n        .filter(e -> {\n\n          ResidentAttributes.State state = e.getAttribute(ResidentAttributes.State.STATE); // STATEã‚­ãƒ¼ãŒ\"state\"æ–‡å­—åˆ—ã¨é‡è¤‡æ³¨æ„ã€‚ResidentAttributes.STATEå®šæ•°ã‚’ä½¿ã†ã€‚\n\n          // Attributeã‚­ãƒ¼ã¯Stringãªã®ã§ã€ResidentAttributes.STATE (=\"state\") ã‚’ä½¿ã†ã€‚\n\n          // getAttributeã®æˆ»ã‚Šå€¤ã¯Enumã€‚\n\n          Object stateObj = e.getAttribute(ResidentAttributes.STATE);\n\n          return stateObj == ResidentAttributes.State.DEAD;\n\n        })\n\n        .filter(e -> e.getPosition().distance(pos) <= harvestRadius)\n\n        .findFirst();\n\n    if (target.isPresent()) {\n\n      GameObject soul = target.get();\n\n      // é­‚å›å\n\n      int soulAmount = 10; // ä»®: ä½æ°‘ã®ç¨®é¡ã‚„ä¿¡ä»°å¿ƒã«ã‚ˆã£ã¦å¤‰å‹•ã•ã›ã‚‹ã¨ãªãŠè‰¯ã„\n\n      // ä¿¡ä»°å¿ƒãƒœãƒ¼ãƒŠã‚¹è¨ˆç®— (ä¾‹)\n\n      Integer faith = soul.getAttribute(ResidentAttributes.FAITH);\n\n      if (faith != null) {\n\n        soulAmount += faith / 5;\n\n      }\n\n      eventBus.publish(EventType.SOUL_HARVESTED, soulAmount);\n\n      destroyEntity(soul);\n\n      return true;\n\n    }\n\n    return false;\n\n  }\n\n  /**\n   * \n   * å»ºç‰©ã‚’å»ºè¨­ã™ã‚‹ã€‚\n   * \n   * @param type å»ºç‰©ã®ç¨®é¡\n   * \n   * @param pos  å»ºè¨­ä½ç½®ï¼ˆã‚°ãƒªãƒƒãƒ‰åº§æ¨™ï¼‰\n   * \n   * @return å»ºè¨­ã«æˆåŠŸã—ãŸã‚‰true\n   * \n   */\n\n  public boolean constructBuilding(BuildingType type, java.awt.geom.Point2D pos) {\n\n    // 1. ã‚³ã‚¹ãƒˆãƒã‚§ãƒƒã‚¯\n\n    if (souls < type.getCost()) {\n\n      return false;\n\n    }\n\n    // 2. ãƒãƒƒãƒ—ä¸Šã®å»ºè¨­å¯å¦ãƒã‚§ãƒƒã‚¯\n\n    // GameMap.placeBuildingå†…ã§ãƒã‚§ãƒƒã‚¯ã•ã‚Œã‚‹ãŒã€ã“ã“ã§ã¯äº‹å‰ã«ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚³ã‚¹ãƒˆæ¶ˆè²»ã‚’åˆ¶å¾¡ã™ã‚‹\n\n    if (!gameMap.isValid(pos) || !gameMap.getCell(pos).canBuild()) {\n\n      return false;\n\n    }\n\n    // 3. å»ºè¨­å‡¦ç†\n\n    // é­‚æ¶ˆè²»\n\n    addSouls(-type.getCost());\n\n    // GameObjectç”Ÿæˆ\n\n    GameObject building = new GameObject(pos);\n\n    // Strategyè¨­å®š\n\n    building.setRenderStrategy(\n        io.github.sasori_256.town_planning.model.strategy.SimpleRenderStrategy.fromBuildingType(type));\n\n    // å»ºç‰©ã”ã¨ã®å›ºæœ‰ãƒ­ã‚¸ãƒƒã‚¯\n\n    if (type == BuildingType.HOUSE) {\n\n      building.setUpdateStrategy(\n          new io.github.sasori_256.town_planning.model.strategy.PopulationGrowthStrategy(type.getCapacity()));\n\n    }\n\n    // ãƒãƒƒãƒ—ã¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒªã‚¹ãƒˆã¸ã®ç™»éŒ²\n\n    // Note: placeBuildingã¯MapCellã¸ã®ç™»éŒ²ã®ã¿ã‚’è¡Œã†ã€‚Entityãƒªã‚¹ãƒˆã¸ã®ç™»éŒ²ã¯åˆ¥é€”å¿…è¦ã€‚\n\n    // ã¾ãŸã€GameObjectã¨GameEntityã®æ•´åˆæ€§ã‚’ä¿ã¤ãŸã‚ã€GameMapã¯GameObjectã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ä¿®æ­£ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œãªã„ãŒã€\n\n    // ç¾çŠ¶ã¯GameMapã¯GameEntityã‚’å—ã‘å–ã‚‹ã€‚GameObjectã¯GameEntityã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã®ã§OKã€‚\n\n    if (gameMap.placeBuilding(pos, building)) {\n\n      addEntity(building);\n\n      return true;\n\n    } else {\n\n      // ä¸‡ãŒä¸€Mapã¸ã®é…ç½®ã«å¤±æ•—ã—ãŸå ´åˆã¯æ‰•ã„æˆ»ã—ï¼ˆé€šå¸¸ã“ã“ã«ã¯æ¥ãªã„ã¯ãšï¼‰\n\n      addSouls(type.getCost());\n\n      return false;\n\n    }\n\n  }\n\n  public int getDay() {\n\n    return day;\n\n  }\n\n}\n"
  }
}
```

---

âœ¨ ## MODEL

**Tool Command**:
```json
{
  "name": "write_file",
  "args": {
    "content": "# Project Context: MPro-Town-Planning\n\n## Overview\n\"God's Town Planning Simulation Game\" (ç¥ã®è¡—ã¥ãã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ).\nThis is a Java-based desktop simulation game where the player acts as a god managing a town. The core gameplay involves managing resources (\"Souls\"), constructing buildings, and handling resident life cycles and events.\n\n## Technical Stack\n*   **Language:** Java 25 (Toolchain configured)\n*   **Build System:** Gradle 9.2 (Wrapper included)\n*   **GUI Framework:** Java Swing (inferred from `GameWindow`)\n*   **Testing:** JUnit 5 (Jupiter)\n*   **Key Libraries:** Guava\n\n## Project Structure\nThe project follows a standard Gradle application structure with a Model-View-Controller (MVC) and Strategy pattern hybrid architecture.\n\n### Key Directories (`app/src/main/java/io/github/sasori_256/town_planning/`)\n*   **`model/`**: Contains the core game data and logic.\n    *   `GameModel.java`: The central hub holding the game state (Map, Entities, Souls, Time). Acts as the `GameContext`.\n    *   `GameMap.java`: Manages the grid-based world.\n    *   `GameObject.java`: Represents entities in the game. Uses strategies for behavior.\n    *   `strategy/`: Implementations of game logic (e.g., `PopulationGrowthStrategy`, `MeteorDisasterStrategy`).\n*   **`view/`**: Handles rendering and UI.\n    *   `GameWindow.java`: The main application window.\n*   **`controller/`**: Manages user input.\n    *   `GameController.java`: Bridges Input and Model.\n*   **`core/`**: Core engine components.\n    *   `GameLoop.java`: Fixed time-step game loop (60 FPS target).\n    *   `EventBus.java` (`event/`): Decouples components via a publish-subscribe system.\n    *   `GameContext.java`: Interface exposing game state to entities.\n\n## Architecture Highlights\n*   **Game Loop:** A custom `GameLoop` class manages the update (tick) and render cycles independently.\n*   **Entity Logic:** Uses a Strategy pattern. `GameObject`s delegate behavior to `UpdateStrategy` and rendering to `RenderStrategy`, allowing flexible entity definitions without deep inheritance hierarchies.\n*   **Event System:** An `EventBus` is used for communication between the Model, View, and other components (e.g., `EventType.SOUL_HARVESTED`, `EventType.DAY_PASSED`).\n*   **Concurrency:** The `GameModel` uses `CopyOnWriteArrayList` for entities to handle concurrent access from the update loop and the rendering thread.\n\n## Development Commands\n\n### Prerequisites\n*   JDK 25 (Gradle toolchain should handle provisioning via Foojay resolver)\n\n### Build & Run\n*   **Run Application:**\n    ```bash\n    ./gradlew run\n    ```\n*   **Run Tests:**\n    ```bash\n    ./gradlew test\n    ```\n*   **Clean Build:**\n    ```bash\n    ./gradlew clean build\n    ```\n\n## Development Conventions\n*   **Naming:** standard Java conventions (CamelCase).\n*   **Comments:** Japanese comments are present in the source code, explaining key logic (e.g., `AtomicBoolean` usage).\n*   **Magic Numbers:** Some constants are defined in `Constants.java`, but `GameLoop` and `GameModel` currently contain some magic numbers (TODO: refactor).\n",
    "file_path": "GEMINI.md"
  }
}
```

---

ğŸ§‘â€ğŸ’» ## USER

**Tool Response**:
```json
{
  "id": "write_file-1765259900476-823a034b568eb",
  "name": "write_file",
  "response": {
    "output": "Successfully overwrote file: C:\\Users\\sasor\\Gitworks\\MPro-Town-Planning\\GEMINI.md."
  }
}
```

---

âœ¨ ## MODEL

I have analyzed the project structure and generated the `GEMINI.md` file. This file contains a comprehensive overview of the project, including its architecture, technical stack, and development commands.

You can now use this file as a reference for future tasks. I am ready for your next command.

---

ğŸ§‘â€ğŸ’» ## USER

ç¾åœ¨ã®GameObjectã«å¯¾ã™ã‚‹strategyã®æ§‹æˆã¯å¤©ç½ã€å»ºç‰©ã€ä½æ°‘ã®3ã¤ã«å¯¾ã™ã‚‹ã‚‚ã®ãŒå…¥ã‚Šæ··ã˜ã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯è‰¯ã„è¨­è¨ˆã§ã—ã‚‡ã†ã‹ï¼Ÿ

---

âœ¨ ## MODEL

ç¾çŠ¶ã® `GameObject` ãŒã€Œä½æ°‘ã€ã€Œå»ºç‰©ã€ã€Œå¤©ç½ã€ã¨ã„ã†å…¨ãç•°ãªã‚‹æ€§è³ªã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€ã™ã¹ã¦ **Strategyï¼ˆæˆ¦ç•¥ï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆã ã‘ã§è¡¨ç¾ã—ã¦ã„ã‚‹** ã¨ã„ã†ç‚¹ã«ã¤ã„ã¦ã€è¨­è¨ˆçš„ãªè¦³ç‚¹ã‹ã‚‰åˆ†æãƒ»å›ç­”ã—ã¾ã™ã€‚

çµè«–ã‹ã‚‰è¨€ã†ã¨ã€**ã€Œãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‚„å°è¦æ¨¡ãªã‚²ãƒ¼ãƒ ã¨ã—ã¦ã¯æŸ”è»Ÿã§å¼·åŠ›ã§ã™ãŒã€è¦æ¨¡ãŒå¤§ãããªã‚‹ã¨ç®¡ç†ãŒé›£ã—ããªã‚‹ãƒªã‚¹ã‚¯ï¼ˆè«¸åˆƒã®å‰£ï¼‰ã‚’å«ã‚“ã§ã„ã‚‹ã€** ã¨è¨€ãˆã¾ã™ã€‚

ä»¥ä¸‹ã«ã€ç¾åœ¨ã®è¨­è¨ˆã®ãƒ¡ãƒªãƒƒãƒˆãƒ»ãƒ‡ãƒ¡ãƒªãƒƒãƒˆã¨ã€ä»Šå¾Œã®æ”¹å–„æ¡ˆã‚’æç¤ºã—ã¾ã™ã€‚

### ç¾çŠ¶ã®åˆ†æï¼šEntity-Component (EC) ãƒ‘ã‚¿ãƒ¼ãƒ³ã«è¿‘ã„æ§‹æˆ
ç¾åœ¨ã® `GameObject` ã¯ã€è‡ªèº«ã®æŒ¯ã‚‹èˆã„ã‚’æŒãŸãšã€`UpdateStrategy` ã‚„ `RenderStrategy` ã‚’å·®ã—è¾¼ã‚€ã“ã¨ã§ã€Œä½•ã«ã§ã‚‚ãªã‚Œã‚‹ã€ç®±ã¨ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã‚²ãƒ¼ãƒ é–‹ç™ºã§ã‚ˆãä½¿ã‚ã‚Œã‚‹ **Entity-Component System (ECS)** ã®ç°¡æ˜“ç‰ˆï¼ˆEntity-Component ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ã«è¿‘ã„æ€æƒ³ã§ã™ã€‚

#### ãƒ¡ãƒªãƒƒãƒˆï¼ˆGoodï¼‰
1.  **æŸ”è»Ÿæ€§ãŒé«˜ã„ï¼ˆComposition over Inheritanceï¼‰:**
    *   ã€Œç§»å‹•ã™ã‚‹å»ºç‰©ã€ã‚„ã€Œæ”»æ’ƒã—ã¦ãã‚‹å¤©ç½ã€ã®ã‚ˆã†ãªã€å¾“æ¥ã®ç¶™æ‰¿é–¢ä¿‚ï¼ˆ`class Building extends GameObject`ï¼‰ã§ã¯è¡¨ç¾ã—ã«ãã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã€Strategyã®çµ„ã¿åˆã‚ã›ã ã‘ã§ç°¡å˜ã«ä½œã‚Œã¾ã™ã€‚
2.  **`GameObject` ã‚¯ãƒ©ã‚¹ãŒè‚¥å¤§åŒ–ã—ãªã„:**
    *   `GameObject` ã« `move()` ã‚„ `growPopulation()` ãªã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è©°ã‚è¾¼ã‚€å¿…è¦ãŒãªãã€ãƒ­ã‚¸ãƒƒã‚¯ãŒå„Strategyã‚¯ãƒ©ã‚¹ã«åˆ†æ•£ã•ã‚Œã‚‹ãŸã‚ã€å€‹ã€…ã®ã‚¯ãƒ©ã‚¹ã¯å°ã•ãä¿ãŸã‚Œã¾ã™ã€‚

#### ãƒ‡ãƒ¡ãƒªãƒƒãƒˆãƒ»ãƒªã‚¹ã‚¯ï¼ˆBadï¼‰
1.  **å±æ€§ï¼ˆãƒ‡ãƒ¼ã‚¿ï¼‰ã®ç®¡ç†ãŒç…©é›‘ã«ãªã‚‹:**
    *   ä½æ°‘ã¯ã€Œå¹´é½¢ãƒ»ä¿¡ä»°å¿ƒã€ã€å»ºç‰©ã¯ã€Œåå®¹äººæ•°ãƒ»è€ä¹…åº¦ã€ã€å¤©ç½ã¯ã€ŒæŒç¶šæ™‚é–“ãƒ»å¼·åº¦ã€ãªã©ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒå…¨ãç•°ãªã‚Šã¾ã™ã€‚
    *   ç¾çŠ¶ã“ã‚Œã‚‰ã‚’ `Map<String, Object>` (Attributes) ã§ç®¡ç†ã—ã¦ã„ã‚‹å ´åˆã€å‹å®‰å…¨æ€§ï¼ˆType Safetyï¼‰ãŒãªããªã‚Šã€ã€Œã‚­ãƒ¼åã®ã‚¹ãƒšãƒ«ãƒŸã‚¹ã€ã‚„ã€Œã‚­ãƒ£ã‚¹ãƒˆãƒŸã‚¹ã€ã«ã‚ˆã‚‹ãƒã‚°ãŒå¤šç™ºã—ã‚„ã™ããªã‚Šã¾ã™ã€‚
2.  **Strategyãƒ•ã‚©ãƒ«ãƒ€ã®ã‚«ã‚ªã‚¹åŒ–:**
    *   ã”æŒ‡æ‘˜ã®é€šã‚Šã€`strategy` ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å†…ã« `MeteorDisasterStrategy`ï¼ˆå¤©ç½ï¼‰ã¨ `PopulationGrowthStrategy`ï¼ˆå»ºç‰©ï¼‰ã¨ `RandomMoveStrategy`ï¼ˆä½æ°‘ï¼‰ãŒä¸¦åˆ—ã«ã‚ã‚‹ã¨ã€å¯èª­æ€§ãŒä¸‹ãŒã‚Šã¾ã™ã€‚
3.  **æ„å‘³ã®å¸Œè–„åŒ–:**
    *   ã‚³ãƒ¼ãƒ‰ä¸Šã§ `GameObject` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¦‹ãŸã ã‘ã§ã¯ã€ãã‚ŒãŒã€Œäººã€ãªã®ã‹ã€Œå®¶ã€ãªã®ã‹åˆ¤åˆ¥ã—ã«ããã€ãƒ‡ãƒãƒƒã‚°æ™‚ã«æ··ä¹±ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

---

### æ”¹å–„æ¡ˆï¼šã©ã†ã™ã¹ãã‹ï¼Ÿ

ä»Šã®ã€ŒæŸ”è»Ÿæ€§ã€ã‚’ç¶­æŒã—ã¤ã¤ã€Œç§©åºã€ã‚’ã‚‚ãŸã‚‰ã™ãŸã‚ã«ã€ä»¥ä¸‹ã®2æ®µéšã®æ”¹å–„ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

#### ãƒ¬ãƒ™ãƒ«1ï¼šãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ•´ç†ï¼ˆã™ãã«ã§ãã‚‹ã“ã¨ï¼‰
ã¾ãšã¯ç‰©ç†çš„ãªé…ç½®ã‚’æ•´ç†ã—ã€é–‹ç™ºè€…ãŒè¿·ã‚ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚æ©Ÿèƒ½çš„ãªå¤‰æ›´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

```text
model/
  â””â”€â”€ strategy/
       â”œâ”€â”€ building/      <-- å»ºç‰©ç”¨ (PopulationGrowth, etc.)
       â”œâ”€â”€ resident/      <-- ä½æ°‘ç”¨ (RandomMove, LifeCycle, etc.)
       â”œâ”€â”€ disaster/      <-- å¤©ç½ç”¨ (Meteor, etc.)
       â””â”€â”€ common/        <-- æ±ç”¨ (SimpleRender, etc.)
```

#### ãƒ¬ãƒ™ãƒ«2ï¼šãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã®å°å…¥ï¼ˆæ¨å¥¨ï¼‰
ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆStrategyï¼‰ã¯ä»Šã®ã¾ã¾ã§è‰¯ã„ã§ã™ãŒã€ãƒ‡ãƒ¼ã‚¿ï¼ˆAttributesï¼‰ã®å‹å®‰å…¨æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ã€å°‚ç”¨ã®ãƒ‡ãƒ¼ã‚¿ãƒ›ãƒ«ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰ã‚’ä½œã‚Šã¾ã™ã€‚

**ç¾çŠ¶:**
```java
// å±é™º: "faith"ã®ã‚¹ãƒšãƒ«ãƒŸã‚¹ã‚„ã€å‹ãŒIntegerã‹ã©ã†ã‹ãŒä¿è¨¼ã•ã‚Œãªã„
int faith = (Integer) entity.getAttribute("faith");
```

**æ”¹å–„æ¡ˆ:**
```java
// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå®šç¾©
interface GameComponent {}

class ResidentData implements GameComponent {
    public int age;
    public int faith;
}

class BuildingData implements GameComponent {
    public int capacity;
    public int durability;
}

// GameObjectå´
public <T extends GameComponent> T getComponent(Class<T> type) { ... }

// ä½¿ç”¨æ™‚: å‹å®‰å…¨
ResidentData data = entity.getComponent(ResidentData.class);
if (data != null) {
    data.faith += 1;
}
```

### çµè«–

**ã€Œå¤©ç½ãƒ»å»ºç‰©ãƒ»ä½æ°‘ãŒå…¥ã‚Šæ··ã˜ã£ã¦ã„ã‚‹ã€ã“ã¨è‡ªä½“ã¯ã€Strategyãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¼·ã¿ï¼ˆå¤šæ…‹æ€§ï¼‰ã§ã‚‚ã‚ã‚‹ãŸã‚ã€å¿…ãšã—ã‚‚æ‚ªã„è¨­è¨ˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**

ã—ã‹ã—ã€**ã€Œãã‚Œã‚‰ãŒæ•´ç†ã•ã‚Œãšã«ãƒ•ãƒ©ãƒƒãƒˆã«ç½®ã‹ã‚Œã¦ã„ã‚‹ã€** çŠ¶æ…‹ã¨ã€**ã€Œãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®é•ã„ã‚’å¸åã™ã‚‹ä»•çµ„ã¿ãŒãªã„ã€** çŠ¶æ…‹ã¯ã€å°†æ¥çš„ã«æŠ€è¡“çš„è² å‚µã«ãªã‚Šã¾ã™ã€‚

**æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:**
ã¾ãšã¯æ‰‹å§‹ã‚ã« `model/strategy` ä»¥ä¸‹ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ `resident`, `building`, `disaster` ã«åˆ†å‰²ãƒ»æ•´ç†ã™ã‚‹ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã†ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚ã“ã‚Œã ã‘ã§ã‚‚è¦‹é€šã—ãŒéšåˆ†è‰¯ããªã‚Šã¾ã™ã€‚

ã“ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã‹ï¼Ÿãã‚Œã¨ã‚‚ã€ã¾ãšã¯ç¾çŠ¶ã®ã¾ã¾æ©Ÿèƒ½è¿½åŠ ã‚’é€²ã‚ã¾ã™ã‹ï¼Ÿ

---

ğŸ§‘â€ğŸ’» ## USER

GameObjectã«ã¤ã„ã¦æ›´ã«è³ªå•ã§ã™ã€‚
ã‚²ãƒ¼ãƒ ç”»é¢ã§å»ºç‰©ã‚„ä½æ°‘ãªã©ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®å‡¦ç†(ä¾‹ãˆã°ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºUIã‚’è¡¨ç¤ºã—ã€ãã®UIã§ã•ã‚‰ã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã„ã˜ã‚‹ãªã©)ã¯ã©ã“ã§ã©ã®ã‚ˆã†ã«å®Ÿè£…ã™ã‚Œã°ã„ã„ã§ã™ã‹ï¼Ÿ

---

âœ¨ ## MODEL

è‰¯ã„è³ªå•ã§ã™ã€‚UIã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã—ã¦è©³ç´°è¡¨ç¤ºãƒ»ç·¨é›†ï¼‰ã¯ã€MVCãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã€ŒControllerï¼ˆå…¥åŠ›ï¼‰ã€ã¨ã€ŒViewï¼ˆè¡¨ç¤ºï¼‰ã€ã®é€£æºãŒæœ€ã‚‚é‡è¦ã«ãªã‚‹éƒ¨åˆ†ã§ã™ã€‚

ç¾çŠ¶ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆEventBus + MVCï¼‰ã‚’æ´»ã‹ã™ãªã‚‰ã€ä»¥ä¸‹ã®ãƒ•ãƒ­ãƒ¼ã§å®Ÿè£…ã™ã‚‹ã®ãŒæœ€ã‚‚ãã‚Œã„ã§ã™ã€‚

### å®Ÿè£…ã®å…¨ä½“ãƒ•ãƒ­ãƒ¼

1.  **Input (Controller):** ãƒã‚¦ã‚¹å…¥åŠ›ã‚’å—ã‘å–ã‚Šã€ç”»é¢åº§æ¨™ã‚’ã‚²ãƒ¼ãƒ å†…åº§æ¨™ã«å¤‰æ›ã—ã¦ã€ãã®ä½ç½®ã«ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç‰¹å®šã™ã‚‹ã€‚
2.  **Event (Model/EventBus):** ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé¸æŠã•ã‚ŒãŸã€ã¨ã„ã†ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã™ã‚‹ã€‚
3.  **UI (View):** ãã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è³¼èª­ã—ã€è©³ç´°ãƒ‘ãƒãƒ«ï¼ˆã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ï¼‰ã‚’è¡¨ç¤ºã™ã‚‹ã€‚
4.  **Edit (View -> Controller):** UIä¸Šã®ãƒœã‚¿ãƒ³ã‚„ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ“ä½œã‚’Controllerã«ä¼ãˆã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã™ã‚‹ã€‚

---

### å…·ä½“çš„ãªå®Ÿè£…ã‚¹ãƒ†ãƒƒãƒ—

#### 1. EventTypeã®è¿½åŠ  (`EventType.java`)
ã¾ãšã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒé¸æŠã•ã‚ŒãŸã“ã¨ã‚’é€šçŸ¥ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’å®šç¾©ã—ã¾ã™ã€‚

```java
public enum EventType {
    // ... æ—¢å­˜ã®ã‚‚ã®
    OBJECT_SELECTED, // ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ GameObject ã‚’æ¸¡ã™
    OBJECT_UPDATED   // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´æ™‚ã«ç”»é¢ã‚’æ›´æ–°ã™ã‚‹ãŸã‚
}
```

#### 2. Inputå‡¦ç†ã®å®Ÿè£… (`GameController.java`)
Swingã® `MouseListener` ã‚’ä½¿ã£ã¦ã‚¯ãƒªãƒƒã‚¯ã‚’æ¤œçŸ¥ã—ã¾ã™ã€‚

```java
// GameControllerå†…ã§ MouseListener ã‚’å®Ÿè£…ã€ã¾ãŸã¯ç„¡åã‚¯ãƒ©ã‚¹ã§è¿½åŠ 
public void setupInput(GameWindow window) {
    window.getCanvas().addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
            handleMouseClick(e.getX(), e.getY());
        }
    });
}

private void handleMouseClick(int screenX, int screenY) {
    // 1. åº§æ¨™å¤‰æ›: ç”»é¢ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ -> ã‚²ãƒ¼ãƒ å†…ã‚°ãƒªãƒƒãƒ‰åº§æ¨™
    // â€» ã“ã“ã§ã¯ 1ã‚°ãƒªãƒƒãƒ‰ = 32px ã¨ä»®å®šã€‚å®Ÿéš›ã¯RenderStrategyã®å®šæ•°ãªã©ã‚’ä½¿ã†
    int gridSize = 32; 
    int gridX = screenX / gridSize;
    int gridY = screenY / gridSize;

    // 2. ãƒ¢ãƒ‡ãƒ«ã¸ã®å•ã„åˆã‚ã›
    // GameModel ã¾ãŸã¯ GameMap ã«ã€Œã“ã®åº§æ¨™ã«èª°ã‹ã„ã‚‹ï¼Ÿã€ã¨èããƒ¡ã‚½ãƒƒãƒ‰ãŒå¿…è¦
    Optional<GameObject> target = gameModel.getEntities()
        .filter(entity -> {
            Point2D pos = entity.getPosition();
            // å³å¯†ãªå½“ãŸã‚Šåˆ¤å®šãªã‚‰çŸ©å½¢åˆ¤å®šã ãŒã€ã“ã“ã§ã¯ç°¡æ˜“çš„ã«ã‚°ãƒªãƒƒãƒ‰ä¸€è‡´ã§
            return (int)pos.getX() == gridX && (int)pos.getY() == gridY;
        })
        .findFirst();

    if (target.isPresent()) {
        // 3. ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ: ã€Œã“ã„ã¤ãŒé¸ã°ã‚ŒãŸãï¼ã€
        gameModel.getEventBus().publish(EventType.OBJECT_SELECTED, target.get());
    } else {
        // ä½•ã‚‚ãªã„ã¨ã“ã‚ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é¸æŠè§£é™¤ï¼ˆnullã‚’é€ã‚‹ãªã©ï¼‰
        gameModel.getEventBus().publish(EventType.OBJECT_SELECTED, null);
    }
}
```

#### 3. UIï¼ˆã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ï¼‰ã®å®Ÿè£… (`view/InspectorPanel.java`)
é¸æŠã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã‚’è¡¨ç¤ºãƒ»ç·¨é›†ã™ã‚‹ãƒ‘ãƒãƒ«ã‚’ä½œã‚Šã¾ã™ã€‚

```java
public class InspectorPanel extends JPanel {
    private JLabel nameLabel;
    private JTextField paramField; // ä¾‹: åå‰ã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†ç”¨
    private GameObject currentTarget;

    public InspectorPanel(EventBus eventBus) {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        
        nameLabel = new JLabel("No Selection");
        add(nameLabel);
        
        // ç·¨é›†UIã®ä¾‹ (ä¿¡ä»°å¿ƒã®å¤‰æ›´ãƒœã‚¿ãƒ³ãªã©)
        JButton boostFaithBtn = new JButton("Boost Faith");
        boostFaithBtn.addActionListener(e -> {
            if (currentTarget != null) {
                // ã“ã“ã§ç›´æ¥å€¤ã‚’æ›¸ãæ›ãˆã‚‹ã€ã‚ã‚‹ã„ã¯ControllerçµŒç”±ã§å¤‰æ›´ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã‚‹
                // ä¾‹: å±æ€§ã‚’æ›´æ–°
                int currentFaith = (int) currentTarget.getAttribute(ResidentAttributes.FAITH);
                currentTarget.setAttribute(ResidentAttributes.FAITH, currentFaith + 10);
                
                // å¤‰æ›´ã‚’é€šçŸ¥ (å†æç”»ã‚„UIæ›´æ–°ã®ãŸã‚)
                eventBus.publish(EventType.OBJECT_UPDATED, currentTarget);
                updateUI(currentTarget); // è‡ªèº«ã®è¡¨ç¤ºã‚‚æ›´æ–°
            }
        });
        add(boostFaithBtn);

        // ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
        eventBus.subscribe(EventType.OBJECT_SELECTED, data -> {
            if (data instanceof GameObject) {
                this.currentTarget = (GameObject) data;
                updateUI(currentTarget);
                setVisible(true);
            } else {
                this.currentTarget = null;
                nameLabel.setText("No Selection");
                setVisible(false); // ä½•ã‚‚ãªã‘ã‚Œã°éš ã™
            }
        });
    }

    private void updateUI(GameObject obj) {
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰æƒ…å ±ã‚’å¼•ã£ã“æŠœã„ã¦è¡¨ç¤º
        // â€» ã“ã“ã§ã‚‚ã—GameObjectãŒComponentåˆ¶ã‚„æ•´ç†ã•ã‚ŒãŸStrategyã‚’æŒã£ã¦ã„ã‚Œã°ã€
        //    if (obj has ResidentData) ã®ã‚ˆã†ã«å‹å®‰å…¨ã«UIã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹
        Object type = obj.getAttribute("type"); // ä»®
        nameLabel.setText("Selected: " + (type != null ? type.toString() : "Unknown"));
    }
}
```

#### 4. GameWindowã¸ã®çµ„ã¿è¾¼ã¿ (`GameWindow.java`)
ãƒ¡ã‚¤ãƒ³ç”»é¢ã®æ¨ªã‚„ä¸‹ã«ã“ã®ãƒ‘ãƒãƒ«ã‚’é…ç½®ã—ã¾ã™ã€‚

```java
public GameWindow(GameModel model) {
    // ...
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®š (ä¾‹: BorderLayout)
    setLayout(new BorderLayout());
    
    // ã‚²ãƒ¼ãƒ ç”»é¢ (Canvas)
    add(gameCanvas, BorderLayout.CENTER);
    
    // ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ (å³å´ã«é…ç½®)
    InspectorPanel inspector = new InspectorPanel(model.getEventBus());
    add(inspector, BorderLayout.EAST);
    
    // ...
}
```

### è¨­è¨ˆä¸Šã®ãƒã‚¤ãƒ³ãƒˆï¼šStrategyãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®å…¼ã­åˆã„

ã€ŒStrategyæ§‹æˆãŒå…¥ã‚Šæ··ã˜ã£ã¦ã„ã‚‹ã€ã¨ã„ã†å‰å›ã®è©±ã¨é–¢é€£ã—ã¾ã™ãŒã€ã“ã®UIå®Ÿè£…æ™‚ã«**ã€Œé¸ã°ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä½•è€…ã‹ï¼ˆä½æ°‘ï¼Ÿå»ºç‰©ï¼Ÿï¼‰ã€ã«ã‚ˆã£ã¦è¡¨ç¤ºã™ã‚‹UIã‚’å¤‰ãˆãŸããªã‚‹**ã¯ãšã§ã™ã€‚

ãã®éš›ã€`GameObject` å†…ã® `if` åˆ†å²ã§é ‘å¼µã‚‹ã®ã§ã¯ãªãã€ä»¥ä¸‹ã®ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã¨ã‚¹ãƒãƒ¼ãƒˆã§ã™ã€‚

1.  **UIè¡¨ç¤ºç”¨ã®Strategyã‚’ä½œã‚‹ (InspectStrategy)**
    *   `UpdateStrategy` ãªã©ã¨åŒæ§˜ã«ã€`InspectStrategy` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã™ã‚‹ã€‚
    *   `ResidentInspectStrategy`ï¼ˆå¹´é½¢ã‚„ä¿¡ä»°å¿ƒã‚’è¡¨ç¤ºï¼‰ã€`BuildingInspectStrategy`ï¼ˆè€ä¹…åº¦ã‚’è¡¨ç¤ºï¼‰ã‚’å®Ÿè£…ã€‚
    *   ã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã‚‰ã€`gameObject.getInspectStrategy().renderPanel(inspectorPanel)` ã®ã‚ˆã†ã«å§”è­²ã™ã‚‹ã€‚

ã“ã†ã™ã‚Œã°ã€æ–°ã—ã„ç¨®é¡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆä¾‹ï¼šUFOï¼‰ã‚’è¿½åŠ ã—ã¦ã‚‚ã€`GameWindow` ã‚„ `InspectorPanel` ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã™ã‚‹ã“ã¨ãªãã€UFOå°‚ç”¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç·¨é›†ç”»é¢ã‚’è¡¨ç¤ºã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

### ã¾ã¨ã‚
*   **å ´æ‰€:** `GameController` ã§ã‚¯ãƒªãƒƒã‚¯æ¤œçŸ¥ -> `EventBus` ã§é€šçŸ¥ -> `View (Swing Panel)` ã§è¡¨ç¤ºã€‚
*   **æ–¹æ³•:** ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’Eventã§æ¸¡ã—ã€UIå´ã§ãã®Attributesã‚’èª­ã¿æ›¸ãã™ã‚‹ã€‚
*   **ç™ºå±•:** ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¨®é¡ã”ã¨ã«UIã‚’å‡ºã—åˆ†ã‘ãŸã„å ´åˆã¯ã€UIè¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯è‡ªä½“ã‚‚Strategyãƒ‘ã‚¿ãƒ¼ãƒ³åŒ–ã™ã‚‹ã¨æ‹¡å¼µæ€§ãŒé«˜ã¾ã‚Šã¾ã™ã€‚

---

ğŸ§‘â€ğŸ’» ## USER

ã•ã£ãã®GameObjectã«ã¤ã„ã¦ã€abstract class ã‚’ç¶™æ‰¿ã—ãŸå»ºç‰©ã€å¤©ç½ã€ä½æ°‘ãªã©ã®å…·è±¡ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã—ã€å…±é€šãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹æ–¹å¼ã®æ–¹ãŒattributesã‚’å‚ç…§ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å½¢ã‚ˆã‚Šã‚‚å˜ç´”ã«æ€ãˆã‚‹ã®ã§ã™ãŒã€ãã“ã¯ã©ã†ãªã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ

---

âœ¨ ## MODEL

ãŠã£ã—ã‚ƒã‚‹é€šã‚Šã§ã™ã€‚**ç¶™æ‰¿ï¼ˆInheritanceï¼‰ã‚’ä½¿ã†æ–¹ãŒã€ä»Šã®æ®µéšã§ã¯åœ§å€’çš„ã«ç›´æ„Ÿçš„ã§ã€ã‚³ãƒ¼ãƒ‰ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚**

ã€ŒAttributesï¼ˆMapï¼‰ã§ä½•ã§ã‚‚ç®¡ç†ã™ã‚‹æ–¹å¼ã€å¯¾ã€Œç¶™æ‰¿ï¼ˆAbstract Class + å…·è±¡ã‚¯ãƒ©ã‚¹ï¼‰ã€ã®æ¯”è¼ƒã‚’ã€å…·ä½“çš„ã«è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### 1. ãªãœã€Œç¶™æ‰¿ã€ã®æ–¹ãŒå˜ç´”ã«è¦‹ãˆã‚‹ï¼ˆãã—ã¦å®Ÿéš›å˜ç´”ï¼‰ãªã®ã‹

#### A. ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ãƒã‚§ãƒƒã‚¯ãŒåŠ¹ãï¼ˆé™çš„å‹ä»˜ã‘ã®æ©æµï¼‰
Javaã¯é™çš„å‹ä»˜ã‘è¨€èªã§ã™ã€‚ç¶™æ‰¿ã‚’ä½¿ãˆã°ã€ãã®å¼·ã¿ã‚’æœ€å¤§é™ã«æ´»ã‹ã›ã¾ã™ã€‚

**ç¶™æ‰¿ã®å ´åˆ (Good):**
```java
// Residentã‚¯ãƒ©ã‚¹ã‚’å®šç¾©
public class Resident extends GameObject {
    private int age;
    
    public void growOld() {
        this.age++; // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒageã®å­˜åœ¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã€‚ã‚¹ãƒšãƒ«ãƒŸã‚¹ã‚‚ã™ãã‚ã‹ã‚‹ã€‚
    }
}

// ä½¿ã†å´
if (obj instanceof Resident) {
    ((Resident) obj).growOld();
}
```

**Attributesã®å ´åˆ (Bad - ç¾çŠ¶):**
```java
// ã‚­ãƒ¼ã¯ãŸã ã®æ–‡å­—åˆ—ã€‚é–“é•ãˆã¦ã‚‚å®Ÿè¡Œã™ã‚‹ã¾ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„ã€‚
int age = (int) obj.getAttribute("gae"); // "age"ã®ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ï¼å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼(NullPointerException or ClassCastException)
```

#### B. IDEã®è£œå®ŒãŒåŠ¹ã
ç¶™æ‰¿ãªã‚‰ `resident.` ã¨æ‰“ã¦ã° `getAge()` ã‚„ `pray()` ãŒå€™è£œã«å‡ºã¾ã™ã€‚Attributesæ–¹å¼ã§ã¯ã€ã©ã‚“ãªã‚­ãƒ¼ãŒå…¥ã£ã¦ã„ã‚‹ã‹æš—è¨˜ã™ã‚‹ã‹ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ãªã„ã¨ã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‘ã¾ã›ã‚“ã€‚

#### C. ãƒ‡ãƒ¼ã‚¿ã¨æŒ¯ã‚‹èˆã„ãŒã‚»ãƒƒãƒˆã«ãªã‚‹ï¼ˆã‚«ãƒ—ã‚»ãƒ«åŒ–ï¼‰
ã€Œä½æ°‘ã€ã‚¯ãƒ©ã‚¹ã®ä¸­ã«ã€Œä½æ°‘ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆå¹´é½¢ï¼‰ã€ã¨ã€Œä½æ°‘ã®å‹•ãï¼ˆç§»å‹•ï¼‰ã€ãŒã¾ã¨ã¾ã£ã¦ã„ã‚‹æ–¹ãŒã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã¨ã—ã¦è‡ªç„¶ã§ã™ã€‚

---

### 2. ã§ã¯ã€ãªãœã€ŒStrategyã€ã‚„ã€ŒComponent (ECS)ã€ãŒæ¨å¥¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã‹ï¼Ÿ

ç¶™æ‰¿ãŒå˜ç´”ã§æœ€å¼·ã«è¦‹ãˆã¾ã™ãŒã€ã‚²ãƒ¼ãƒ é–‹ç™ºã®æ­´å²ã®ä¸­ã§ã€Œç¶™æ‰¿ã®é™ç•Œã€ãŒéœ²å‘ˆã—ã¦ããŸãŸã‚ã€ECSãªã©ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç”Ÿã¾ã‚Œã¾ã—ãŸã€‚

**ç¶™æ‰¿ã®ã€Œæ­»ã®è±å½¢ï¼ˆDiamond Problemï¼‰ã€ã¨ç¡¬ç›´æ€§ã®å•é¡Œ:**

ä¾‹ãˆã°ã€ã€Œ**å‹•ã**ï¼ˆMoveableï¼‰ã€æ©Ÿèƒ½ã¨ã€Œ**æ”»æ’ƒã™ã‚‹**ï¼ˆAttackableï¼‰ã€æ©Ÿèƒ½ã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã¨ã—ã¾ã™ã€‚

1.  `class Soldier extends Resident` ï¼ˆå‹•ãã—ã€æ”»æ’ƒã‚‚ã™ã‚‹ï¼‰ -> OK
2.  `class Tower extends Building` ï¼ˆå‹•ã‹ãªã„ã€æ”»æ’ƒã™ã‚‹ï¼‰ -> OK
3.  ã“ã“ã§**ã€Œå‹•ãæˆ¦è»Šï¼ˆVehicleï¼‰ã€**ã‚’ä½œã‚ŠãŸã„ã€‚
    *   `Vehicle` ã¯ `Building`ï¼ˆç„¡æ©Ÿç‰©ï¼‰ï¼Ÿ ã§ã‚‚å‹•ãå¿…è¦ãŒã‚ã‚‹ã€‚
    *   ã˜ã‚ƒã‚ `GameObject` ã®ç›´ä¸‹ï¼Ÿ ã§ã‚‚ `Soldier` ã®ç§»å‹•ã‚³ãƒ¼ãƒ‰ã¨ `Tower` ã®æ”»æ’ƒã‚³ãƒ¼ãƒ‰ã‚’å†åˆ©ç”¨ã—ãŸã„â€¦ã‚³ãƒ”ãƒšã™ã‚‹ï¼Ÿ
    *   **ã€Œå¤šé‡ç¶™æ‰¿ã€ãŒã§ããªã„Javaã§ã¯ã€ã“ã“ã§è©°ã¿ã¾ã™ã€‚**

Strategyãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„ECSã¯ã€ã“ã‚Œã‚’ã€Œå‹•ãéƒ¨å“ã€ã¨ã€Œæ”»æ’ƒã™ã‚‹éƒ¨å“ã€ã‚’ãã£ã¤ã‘ã‚‹ï¼ˆCompositionï¼‰ã“ã¨ã§è§£æ±ºã—ã¾ã™ã€‚

---

### 3. ä»Šå›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã‘ã‚‹ã€Œæ­£è§£ã€ã¯ï¼Ÿ

ä»Šå›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è¦æ¨¡æ„Ÿã¨Javaã¨ã„ã†è¨€èªç‰¹æ€§ã‚’è€ƒãˆã‚‹ã¨ã€**ã€Œç¶™æ‰¿ã€ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ã¤ã¤ã€éƒ¨åˆ†çš„ã«ã€ŒStrategyã€ã‚’ä½¿ã†ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰**ãŒæœ€ã‚‚ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„ã§ã™ã€‚

ã€Œä½•ã§ã‚‚ã‹ã‚“ã§ã‚‚Strategy/Attributesã«ã™ã‚‹ã€ã®ã¯ã‚„ã‚Šã™ãï¼ˆOver-engineeringï¼‰ã§ã€é€†ã«ã‚³ãƒ¼ãƒ‰ã‚’è¤‡é›‘ã«ã—ã¦ã„ã¾ã™ã€‚

**æ¨å¥¨ã™ã‚‹æ§‹æˆæ¡ˆ:**

```java
// åŸºåº•ã‚¯ãƒ©ã‚¹
public abstract class GameObject {
    protected Point2D position;
    protected RenderStrategy renderStrategy; // æç”»ã ã‘ã¯Strategyã«æ®‹ã—ã¦ã‚‚ã„ã„ï¼ˆã‚¹ã‚­ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆãªã©ä¾¿åˆ©ï¼‰
    
    public abstract void update(GameModel model); // å…·ä½“çš„ãªå‹•ãã¯å­ãŒå®Ÿè£…
}

// å…·è±¡ã‚¯ãƒ©ã‚¹ï¼ˆãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã—ã£ã‹ã‚Šå®šç¾©ï¼‰
public class Resident extends GameObject {
    private int age;
    private int faith;
    
    @Override
    public void update(GameModel model) {
        // ä½æ°‘ç‰¹æœ‰ã®å‹•ã
        moveRandomly();
        growOld();
    }
    
    // ã‚²ãƒƒã‚¿ãƒ¼ã‚»ãƒƒã‚¿ãƒ¼ï¼ˆå‹å®‰å…¨ï¼ï¼‰
    public int getAge() { return age; }
}

public class Building extends GameObject {
    private int durability;
    private BuildingType type;
    
    @Override
    public void update(GameModel model) {
        // å»ºç‰©ç‰¹æœ‰ã®å‡¦ç†ï¼ˆä¾‹ãˆã°ç”Ÿç”£ãªã©ï¼‰
    }
}
```

### çµè«–

**ã¯ã„ã€ç¾çŠ¶ã®ã€ŒAttributes + å®Œå…¨Strategyã€æ–¹å¼ã‚ˆã‚Šã‚‚ã€ã€Œç¶™æ‰¿ã‚’ä½¿ã£ãŸå…·è±¡ã‚¯ãƒ©ã‚¹ã€ã‚’ä½œæˆã™ã‚‹æ–¹å¼ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ã‚’å¼·ããŠå‹§ã‚ã—ã¾ã™ã€‚**

ç†ç”±ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š
1.  **ã‚·ãƒ³ãƒ—ãƒ«ã•:** ã‚³ãƒ¼ãƒ‰ãŒèª­ã¿ã‚„ã™ãã€æ›¸ãã‚„ã™ããªã‚Šã¾ã™ã€‚
2.  **å®‰å…¨æ€§:** ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ãƒã‚°ã«æ°—ã¥ã‘ã¾ã™ã€‚
3.  **ååˆ†ãªæ‹¡å¼µæ€§:** ä»Šå›ã®ã‚²ãƒ¼ãƒ ä»•æ§˜ï¼ˆä½æ°‘ã€å»ºç‰©ã€å¤©ç½ï¼‰ãªã‚‰ã€ç¶™æ‰¿éšå±¤ãŒæ·±ããªã‚Šã™ãã¦ç ´ç¶»ã™ã‚‹ã“ã¨ã¯ã¾ãšã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã€Œç§»å‹•ã™ã‚‹å»ºç‰©ã€ãŒå‡ºã¦ãã¦ã‚‚ã€ãã®æ™‚ã ã‘ä¾‹å¤–çš„ã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ç­‰ã§å¯¾å¿œã™ã‚Œã°æ¸ˆã¿ã¾ã™ã€‚

ã“ã®ã€Œç¶™æ‰¿ãƒ™ãƒ¼ã‚¹ã€ã¸ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ï¼ˆGameObjectã‚’æŠ½è±¡ã‚¯ãƒ©ã‚¹åŒ–ã—ã€Resident/Buildingã‚¯ãƒ©ã‚¹ã‚’ä½œæˆï¼‰ã‚’è¡Œã†ãƒ—ãƒ©ãƒ³ã‚’ç«‹ã¦ã¾ã—ã‚‡ã†ã‹ï¼Ÿ

---

ğŸ§‘â€ğŸ’» ## USER

ã“ã†ãªã£ãŸå ´åˆã€enumã§å»ºç‰©ä¸€è¦§ã‚’åˆ—æŒ™ã™ã‚‹ã‹ã€buildingã‚¯ãƒ©ã‚¹ã§å®šç¾©ã—ã€å„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å®Ÿè£…ã™ã‚‹ã‹ã€ä»–ã®æ–¹å¼ã‹ã€ã©ã®å®Ÿè£…ãŒã„ã„ã§ã™ã‹ï¼Ÿ

---

âœ¨ ## MODEL

å»ºç‰©ãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†æ–¹æ³•ï¼ˆç¨®é¡ã”ã¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©ï¼‰ã«ã¤ã„ã¦ã§ã™ã­ã€‚
çµè«–ã‹ã‚‰è¨€ã†ã¨ã€**ã€ŒEnumã§åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã‚’å®šç¾©ã—ã€Buildingã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆæ™‚ã«ãã‚Œã‚’èª­ã¿è¾¼ã‚€ã€** æ–¹å¼ãŒã€Javaã§ã®ã“ã®ç¨®ã®ã‚²ãƒ¼ãƒ é–‹ç™ºã«ãŠã„ã¦æœ€ã‚‚å …å®Ÿã§æ‰±ã„ã‚„ã™ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆType Object Pattern ã®ä¸€ç¨®ï¼‰ã§ã™ã€‚

ãã‚Œãã‚Œã®æ–¹å¼ã®æ¯”è¼ƒã¨ã€æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚

### 1. æ¯”è¼ƒæ¤œè¨

#### æ¡ˆA: Enumã§åˆ—æŒ™ã™ã‚‹ (æ¨å¥¨)
`BuildingType` Enum ã«ã€ã‚³ã‚¹ãƒˆã€è€ä¹…åº¦ã€åå®¹äººæ•°ãªã©ã®ã€Œå®šæ•°ãƒ‡ãƒ¼ã‚¿ã€ã‚’æŒãŸã›ã¾ã™ã€‚

*   **ãƒ¡ãƒªãƒƒãƒˆ:**
    *   **å®šç¾©ãŒä¸€ç®‡æ‰€ã«ã¾ã¨ã¾ã‚‹:** ã€Œå®¶ã®ã‚³ã‚¹ãƒˆã‚’å¤‰ãˆãŸã„ã€ã¨æ€ã£ãŸã‚‰Enumã‚’è¦‹ã‚‹ã ã‘ã§ã„ã„ã€‚
    *   **ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„:** ç¨®é¡ï¼ˆTypeï¼‰è‡ªä½“ã‚’IDã¨ã—ã¦æ‰±ãˆã‚‹ã®ã§ã€ä¿å­˜ãƒ»ãƒ­ãƒ¼ãƒ‰ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é€šä¿¡ãŒæ¥½ã€‚
    *   **ã‚³ãƒ¼ãƒ‰è£œå®Œ:** `BuildingType.HOUSE` ã¨æ‰“ã¦ã‚‹ã®ã§ãƒŸã‚¹ãŒãªã„ã€‚
*   **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ:**
    *   å‹•çš„ã«æ–°ã—ã„å»ºç‰©ã‚’è¿½åŠ ï¼ˆMODå¯¾å¿œãªã©ï¼‰ã—ã«ãã„ï¼ˆã‚³ãƒ¼ãƒ‰ã®å†ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¿…è¦ï¼‰ã€‚

#### æ¡ˆB: Buildingã‚¯ãƒ©ã‚¹ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ (éæ¨å¥¨)
`class House extends Building`, `class Farm extends Building` ... ã¨ã‚¯ãƒ©ã‚¹ã‚’é‡ç”£ã™ã‚‹ã€‚

*   **ãƒ¡ãƒªãƒƒãƒˆ:**
    *   å»ºç‰©ã”ã¨ã«å…¨ãç•°ãªã‚‹ç‰¹æ®ŠãªæŒ™å‹•ï¼ˆãƒ¡ã‚½ãƒƒãƒ‰ï¼‰ã‚’æ›¸ãã‚„ã™ã„ã€‚
*   **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ:**
    *   **ã‚¯ãƒ©ã‚¹çˆ†ç™º:** å»ºç‰©ã®ç¨®é¡ãŒ50å€‹ã«ãªã£ãŸã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒ50å€‹å¢—ãˆã‚‹ã€‚ç®¡ç†ä¸èƒ½ã€‚
    *   ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼‰ã¨ãƒ­ã‚¸ãƒƒã‚¯ã®åˆ†é›¢ãŒã§ãã¦ã„ãªã„ã€‚

#### æ¡ˆC: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ« (JSON/XML) ã‹ã‚‰èª­ã¿è¾¼ã‚€ (ç™ºå±•çš„)
å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ã«å®šç¾©ã—ã¦ã€èµ·å‹•æ™‚ã«èª­ã¿è¾¼ã‚“ã§ `Map<String, BuildingStats>` ã®ã‚ˆã†ã«ä¿æŒã™ã‚‹ã€‚

*   **ãƒ¡ãƒªãƒƒãƒˆ:**
    *   ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ›¸ãæ›ãˆãšã«ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãŒã§ãã‚‹ã€‚MODå¯¾å¿œãŒå¯èƒ½ã€‚
*   **ãƒ‡ãƒ¡ãƒªãƒƒãƒˆ:**
    *   å®Ÿè£…ã‚³ã‚¹ãƒˆãŒé«˜ã„ï¼ˆãƒ‘ãƒ¼ã‚µãƒ¼ãŒå¿…è¦ï¼‰ã€‚
    *   IDEã®è£œå®ŒãŒåŠ¹ã‹ãªã„ã€‚

---

### 2. æ¨å¥¨å®Ÿè£…ï¼šEnum + Buildingã‚¯ãƒ©ã‚¹

ä»Šå›ã¯ã€Œæ¡ˆAã€ã‚’æ¡ç”¨ã—ã€Enumã‚’ã€Œè¨­è¨ˆå›³ï¼ˆBlueprintï¼‰ã€ã€Buildingã‚¯ãƒ©ã‚¹ã‚’ã€Œå®Ÿä½“ï¼ˆInstanceï¼‰ã€ã¨ã—ã¦æ‰±ã†ã®ãŒãƒ™ã‚¹ãƒˆã§ã™ã€‚

#### Step 1: BuildingType (è¨­è¨ˆå›³)
å®šæ•°ãƒ‡ãƒ¼ã‚¿ã‚’ã“ã“ã«é›†ç´„ã—ã¾ã™ã€‚

```java
public enum BuildingType {
    HOUSE("House", 100, 4, 50),     // åå‰, ã‚³ã‚¹ãƒˆ, åå®¹äººæ•°, è€ä¹…åº¦
    FARM("Farm", 200, 2, 30),
    SHRINE("Shrine", 500, 0, 100);

    private final String name;
    private final int cost;
    private final int capacity;
    private final int maxDurability;

    BuildingType(String name, int cost, int capacity, int maxDurability) {
        this.name = name;
        this.cost = cost;
        this.capacity = capacity;
        this.maxDurability = maxDurability;
    }

    // getters...
    public int getCost() { return cost; }
    public int getMaxDurability() { return maxDurability; }
    // ...
}
```

#### Step 2: Building (å®Ÿä½“)
ç”Ÿæˆæ™‚ã«Enumã‚’å—ã‘å–ã‚Šã€åˆæœŸçŠ¶æ…‹ã‚’è¨­å®šã—ã¾ã™ã€‚

```java
public class Building extends GameObject {
    private final BuildingType type; // ç¨®é¡ã‚’ä¿æŒ
    private int currentDurability;   // å¤‰åŒ–ã™ã‚‹å€¤ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§æŒã¤
    private int currentPopulation;

    public Building(Point2D position, BuildingType type) {
        super(position);
        this.type = type;
        
        // Enumã‹ã‚‰åˆæœŸå€¤ã‚’ã‚³ãƒ”ãƒ¼
        this.currentDurability = type.getMaxDurability();
        this.currentPopulation = 0;
        
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è¨­å®šã‚‚Enumã‹ã‚‰è‡ªå‹•æ±ºå®šã§ãã‚‹
        // this.renderStrategy = new SpriteRenderStrategy(type.getImageName());
    }

    @Override
    public void update(GameModel model) {
        // å…±é€šã®å»ºç‰©ãƒ­ã‚¸ãƒƒã‚¯
        if (currentDurability <= 0) {
            model.destroyEntity(this);
        }
    }

    // å›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ãªå ´åˆã¯Enumã‚’è¦‹ã‚‹
    public int getMaxHp() {
        return type.getMaxDurability();
    }
}
```

### 3. ã“ã®è¨­è¨ˆã®ç´ æ™´ã‚‰ã—ã„ç‚¹

1.  **ãƒ‡ãƒ¼ã‚¿ã®åˆ†é›¢:** ã€Œå¤‰ã‚ã‚‰ãªã„å€¤ï¼ˆã‚³ã‚¹ãƒˆã€æœ€å¤§HPï¼‰ã€ã¯Enumã«ã€ã€Œå¤‰ã‚ã‚‹å€¤ï¼ˆç¾åœ¨ã®HPï¼‰ã€ã¯ã‚¯ãƒ©ã‚¹ã«ã‚ã‚‹ã®ã§æ•´ç†ã•ã‚Œã¦ã„ã¾ã™ã€‚
2.  **æ‹¡å¼µæ€§:** ä¾‹ãˆã°ã€Œè¾²å ´ã ã‘ç‰¹åˆ¥ãªå‡¦ç†ã‚’ã—ãŸã„ã€å ´åˆã§ã‚‚ã€Enumã« `Runnable` ã‚„ `Strategy` ã‚’æŒãŸã›ã‚‹ã“ã¨ã§ã€ã‚¯ãƒ©ã‚¹ã‚’å¢—ã‚„ã•ãšã«å¯¾å¿œã§ãã¾ã™ã€‚

```java
// Enumã«æŒ¯ã‚‹èˆã„ã‚’æŒãŸã›ã‚‹ä¾‹
FARM("Farm", ..., (building, model) -> {
    // è¾²å ´å›ºæœ‰ã®æ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†: é£Ÿæ–™ç”Ÿç”£ãªã©
    model.addFood(1);
});
```

ã“ã®ã€ŒEnum + ã‚¯ãƒ©ã‚¹ã€ã®æ§‹æˆã§å®Ÿè£…ã‚’é€²ã‚ã¦ã‚ˆã‚ã—ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

---

ğŸ§‘â€ğŸ’» ## USER

UIã§å»ºç¯‰ç‰©è¨­ç½®ãƒ¢ãƒ¼ãƒ‰ã¨å¤©ç½ç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã‚‹ãƒœã‚¿ãƒ³ã€ãã—ã¦ãã“ã‹ã‚‰åŒã˜ãƒœã‚¿ãƒ³é…åˆ—ã«å„å»ºç‰©ã®ç”Ÿæˆãƒ¡ã‚½ãƒƒãƒ‰ã€ãŠã‚ˆã³å¤©ç½ç™ºç”Ÿãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™UIè¦ç´ ã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã—ã¦ãŠã‚Šã€å‡¦ç†ã®éç¨‹ã§CategoryNodeã‚¯ãƒ©ã‚¹ã«ItemNodeã‚’é…åˆ—ã§å…¥ã‚Œã€ItemNodeã§BuildingTypeã¾ãŸã¯DisasterTypeã‚’å…¥ã‚Œã‚‹ã¨ã„ã†æ–¹æ³•ã¯è‰¯ã„å®Ÿè£…ã§ã™ã‹ï¼Ÿ

---

âœ¨ ## MODEL

ã¯ã„ã€**ã€ŒCategoryNodeï¼ˆã‚«ãƒ†ã‚´ãƒªï¼‰ã€ã¨ã€ŒItemNodeï¼ˆå€‹åˆ¥ã®é …ç›®ï¼‰ã€ã¨ã„ã†ãƒ„ãƒªãƒ¼æ§‹é€ ã§UIãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†ã—ã€ãã“ã«Enumï¼ˆBuildingType / DisasterTypeï¼‰ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹** ã¨ã„ã†ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€éå¸¸ã«ç†ã«ã‹ãªã£ãŸè‰¯ã„å®Ÿè£…ã§ã™ã€‚

ã“ã®æ–¹æ³•ã¯ **Command ãƒ‘ã‚¿ãƒ¼ãƒ³** ã‚„ **Composite ãƒ‘ã‚¿ãƒ¼ãƒ³** ã®è€ƒãˆæ–¹ã«è¿‘ãã€UIã®æç”»ãƒ­ã‚¸ãƒƒã‚¯ã¨å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ã‚’ãã‚Œã„ã«åˆ†é›¢ã§ãã¾ã™ã€‚

å…·ä½“çš„ã«ä½•ãŒè‰¯ã„ã®ã‹ã€ãã—ã¦å®Ÿè£…æ™‚ã®ãƒã‚¤ãƒ³ãƒˆã‚’æ•´ç†ã—ã¾ã™ã€‚

### è‰¯ã„ç‚¹ (Good)

1.  **æ‹¡å¼µæ€§ (Scalability):**
    *   å°†æ¥ã€Œå¥‡è·¡ï¼ˆMiraclesï¼‰ã€ã‚„ã€Œåœ°å½¢æ“ä½œï¼ˆTerraformingï¼‰ã€ã¨ã„ã£ãŸæ–°ã—ã„ã‚«ãƒ†ã‚´ãƒªãŒå¢—ãˆã¦ã‚‚ã€`CategoryNode` ã‚’ã‚‚ã†ä¸€ã¤å¢—ã‚„ã™ã ã‘ã§æ¸ˆã¿ã¾ã™ã€‚UIå´ã®ã‚³ãƒ¼ãƒ‰ï¼ˆãƒœã‚¿ãƒ³ç”Ÿæˆãƒ«ãƒ¼ãƒ—ãªã©ï¼‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
2.  **æŠ½è±¡åŒ– (Abstraction):**
    *   UIå´ã¯ã€Œã“ã®ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ä½•ã‚’ã™ã‚‹ã‹ï¼ˆBuildingTypeãªã®ã‹DisasterTypeãªã®ã‹ï¼‰ã€ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚`ItemNode` ãŒã€Œå®Ÿè¡Œã™ã‚‹ã€ã¨ã„ã†å…±é€šã®æŒ¯ã‚‹èˆã„ã‚’æŒã£ã¦ã„ã‚Œã°ã€UIã¯ãŸã  `itemNode.execute()` ã‚’å‘¼ã¶ã ã‘ã§æ¸ˆã¿ã¾ã™ã€‚
3.  **éšå±¤æ§‹é€ ã®è¡¨ç¾:**
    *   ã€Œå»ºç¯‰ãƒ¢ãƒ¼ãƒ‰ -> å®¶ / è¾²å ´ / ç¥ç¤¾ã€ã®ã‚ˆã†ã«ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼éšå±¤ã‚’è‡ªç„¶ã«ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã¨ã—ã¦è¡¨ç¾ã§ãã¦ã„ã¾ã™ã€‚

### å®Ÿè£…ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹

ã‚ˆã‚Šæ´—ç·´ã•ã‚ŒãŸå®Ÿè£…ã«ã™ã‚‹ãŸã‚ã«ã€Javaã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

#### 1. å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®šç¾© (`MenuItem`)
`ItemNode` ãŒä¸­èº«ã¨ã—ã¦æŒã¤ã¹ãã€Œå®Ÿè¡Œå¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€ã‚’æŠ½è±¡åŒ–ã—ã¾ã™ã€‚

```java
// ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ãŒæŒã¤ã¹ãå…±é€šã®æŒ¯ã‚‹èˆã„
public interface GameAction {
    String getName(); // UIè¡¨ç¤ºå
    void execute(GameModel model, Point2D targetPos); // å®Ÿè¡Œå‡¦ç†
    // å¿…è¦ãªã‚‰ Icon getIcon(); ãªã©ã‚‚è¿½åŠ 
}
```

#### 2. Enumã«ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã•ã›ã‚‹ (Power Move!)
ã“ã‚ŒãŒJavaã®Enumã®å¼·åŠ›ãªã¨ã“ã‚ã§ã™ã€‚`BuildingType` ã¨ `DisasterType` ã«ç›´æ¥ã“ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã•ã›ã‚‹ã¨ã€ãƒ©ãƒƒãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã™ã‚‰ä¸è¦ã«ãªã‚‹ã‹ã€éå¸¸ã«è–„ããªã‚Šã¾ã™ã€‚

```java
// å»ºç‰©ã®Enum
public enum BuildingType implements GameAction {
    HOUSE("House"),
    FARM("Farm");

    private final String name;
    // ...

    @Override
    public void execute(GameModel model, Point2D targetPos) {
        // GameModelã«å®Ÿè£…äºˆå®šã®å»ºè¨­ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶
        model.constructBuilding(this, targetPos);
    }
}

// å¤©ç½ã®Enum
public enum DisasterType implements GameAction {
    METEOR("Meteor");
    
    // ...

    @Override
    public void execute(GameModel model, Point2D targetPos) {
        // GameModelã«å®Ÿè£…äºˆå®šã®å¤©ç½ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶
        model.triggerDisaster(this, targetPos);
    }
}
```

#### 3. CategoryNode / ItemNode ã®æ§‹æˆ
UIæ§‹ç¯‰ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã§ã™ã€‚

```java
public class CategoryNode {
    private String name;
    private List<GameAction> items; // BuildingTypeã‚„DisasterTypeãŒæ··åœ¨ã§ãã‚‹ï¼

    public CategoryNode(String name, List<GameAction> items) {
        this.name = name;
        this.items = items;
    }
    
    // getters...
}
```

#### 4. UIå´ã§ã®åˆ©ç”¨
ã“ã®ã‚ˆã†ã«ã™ã‚Œã°ã€UIã®æ§‹ç¯‰ã‚³ãƒ¼ãƒ‰ã¯éå¸¸ã«æ±ç”¨çš„ã«ãªã‚Šã¾ã™ã€‚

```java
// UIæ§‹ç¯‰æ“¬ä¼¼ã‚³ãƒ¼ãƒ‰
for (CategoryNode category : categories) {
    createCategoryButton(category.getName(), () -> {
        // ã‚«ãƒ†ã‚´ãƒªãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ã€ã‚µãƒ–ãƒœã‚¿ãƒ³ã‚’å±•é–‹
        showSubButtons(category.getItems());
    });
}

void showSubButtons(List<GameAction> items) {
    panel.clear();
    for (GameAction action : items) {
        createActionButton(action.getName(), () -> {
            // ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰ã¨ã—ã¦ã“ã®Actionã‚’ä¿æŒ
            currentMode = action; 
        });
    }
}

// ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯æ™‚
void onMapClick(Point2D pos) {
    if (currentMode != null) {
        currentMode.execute(gameModel, pos); // ã“ã“ã§ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ãŒåƒã
    }
}
```

### çµè«–
ã‚ãªãŸã®è€ƒãˆã¦ã„ã‚‹ `CategoryNode` - `ItemNode` - `Type(Enum)` ã¨ã„ã†æ§‹æˆã¯ã€**UIã®æ§‹æˆè¦ç´ ã‚’ãƒ‡ãƒ¼ã‚¿åŒ–ã—ã¦æ‰±ã†** ã¨ã„ã†ç‚¹ã§éå¸¸ã«ãƒ¢ãƒ€ãƒ³ã§è‰¯ã„è¨­è¨ˆã§ã™ã€‚

ä¸Šè¨˜ã®ã‚ˆã†ã« `interface` ã‚’å™›ã¾ã›ã‚‹ã“ã¨ã§ã€å‹å®‰å…¨ã‹ã¤æŸ”è»Ÿã«ã€Œå»ºç¯‰ã€ã¨ã€Œå¤©ç½ã€ã‚’çµ±ä¸€çš„ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã®æ–¹é‡ã§å®Ÿè£…ã‚’é€²ã‚ã¦å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

---

ğŸ§‘â€ğŸ’» ## USER

ä»Šã®å®Ÿè£…ã¯commandãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åæ˜ ã—ã¦ã„ã‚‹ã‚‚ã®ã«ãªã£ã¦ã„ã‚‹ã®ã§ã™ã‹ï¼Ÿ

---

âœ¨ ## MODEL

ã¯ã„ã€ã‚ãªãŸãŒæ§‹æƒ³ã—ã¦ã„ã‚‹ã€ŒUIãƒœã‚¿ãƒ³ã« `BuildingType` ã‚„ `DisasterType` ã‚’å‰²ã‚Šå½“ã¦ã¦ã€ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ãã‚Œã‚’å®Ÿè¡Œã™ã‚‹ã€ã¨ã„ã†æ§‹é€ ã¯ã€**Command ãƒ‘ã‚¿ãƒ¼ãƒ³ (Command Pattern) ã®å®Ÿè³ªçš„ãªé©ç”¨ä¾‹** ã¨è¨€ãˆã¾ã™ã€‚

å³å¯†ãªå®šç¾©ã«ç…§ã‚‰ã—åˆã‚ã›ãªãŒã‚‰è§£èª¬ã—ã¾ã™ã€‚

### Command ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã¯ï¼Ÿ
ã€Œãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆå‘½ä»¤ï¼‰ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã‚«ãƒ—ã‚»ãƒ«åŒ–ã™ã‚‹ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç™ºè¡Œè€…ï¼ˆUIãƒœã‚¿ãƒ³ï¼‰ã¨ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å—ä¿¡è€…ï¼ˆGameModelï¼‰ã‚’åˆ†é›¢ã§ãã¾ã™ã€‚

#### ã‚ãªãŸã®è¨­è¨ˆã¨ã®å¯¾å¿œé–¢ä¿‚

| Command ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ§‹æˆè¦ç´  | ã‚ãªãŸã®è¨­è¨ˆ / ç§ã®ææ¡ˆã—ãŸå®Ÿè£… | å½¹å‰² |
| :--- | :--- | :--- |
| **Command (Interface)** | `GameAction` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ | ã€Œå®Ÿè¡Œã§ãã‚‹ä½•ã‹ã€ã¨ã„ã†æŠ½è±¡çš„ãªå®šç¾©ã€‚ |
| **ConcreteCommand** | `BuildingType` / `DisasterType` (ã®å„è¦ç´ ) | å…·ä½“çš„ãªå‘½ä»¤ã€‚ã€Œå®¶ã‚’å»ºã¦ã‚ã€ã€Œéš•çŸ³ã‚’è½ã¨ã›ã€ã€‚ |
| **Invoker (ç™ºå‹•è€…)** | `GameController` ã¾ãŸã¯ UIã®ãƒœã‚¿ãƒ³ | ã‚³ãƒãƒ³ãƒ‰ã‚’ä¿æŒã—ã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼ˆã‚¯ãƒªãƒƒã‚¯æ™‚ï¼‰ãŒæ¥ãŸã‚‰ `execute()` ã‚’å‘¼ã¶å½¹ã€‚ |
| **Receiver (å—ä¿¡è€…)** | `GameModel` | å®Ÿéš›ã«å‡¦ç†ã‚’è¡Œã†å½¹ã€‚`constructBuilding()` ç­‰ã®å®Ÿè£…å ´æ‰€ã€‚ |
| **Client (ä¾é ¼è€…)** | åˆæœŸåŒ–ã‚³ãƒ¼ãƒ‰ (Main/Setup) | ã©ã®ãƒœã‚¿ãƒ³ã«ã©ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã‹ã‚’è¨­å®šã™ã‚‹å ´æ‰€ã€‚ |

### ãªãœã“ã‚ŒãŒ Command ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è¨€ãˆã‚‹ã®ã‹ï¼Ÿ

1.  **ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŒ–ã•ã‚Œã¦ã„ã‚‹:**
    ã€Œå®¶ã‚’å»ºã¦ã‚‹ã€ã¨ã„ã†å‹•ä½œãŒã€é–¢æ•°å‘¼ã³å‡ºã—ãã®ã‚‚ã®ã§ã¯ãªãã€`BuildingType.HOUSE` ã¨ã„ã†**ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**ï¼ˆEnumå®šæ•°ï¼‰ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å¤‰æ•°ã«å…¥ã‚ŒãŸã‚Šã€ãƒªã‚¹ãƒˆï¼ˆ`CategoryNode` ã®ä¸­èº«ï¼‰ã«å…¥ã‚ŒãŸã‚Šã§ãã¾ã™ã€‚ã“ã‚ŒãŒCommandãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ ¸å¿ƒã§ã™ã€‚

2.  **å®Ÿè¡Œã®é…å»¶:**
    UIãƒœã‚¿ãƒ³ã‚’ä½œã£ãŸæ™‚ç‚¹ã§ã¯å®Ÿè¡Œã•ã‚Œãšã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸï¼ˆã‚ã‚‹ã„ã¯ãƒãƒƒãƒ—ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸï¼‰ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ `execute()` ãŒå‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã‚‚Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç‰¹å¾´ã§ã™ã€‚

3.  **æ‹¡å¼µæ€§:**
    æ–°ã—ã„ã‚³ãƒãƒ³ãƒ‰ï¼ˆä¾‹: `MiracleType.HEAL`ï¼‰ã‚’è¿½åŠ ã—ã¦ã‚‚ã€Invokerï¼ˆUIã‚„ã‚¯ãƒªãƒƒã‚¯å‡¦ç†ï¼‰ã®ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

### çµè«–
ã¯ã„ã€ã‚ãªãŸã®è¨­è¨ˆã¯ **Command ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ï¼ˆæ„è­˜ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã‹ã‹ã‚ã‚‰ãšï¼‰æ­£ã—ãåæ˜ ã—ã¦ã„ã¾ã™**ã€‚ç‰¹ã«ã€Enumã«ãƒ­ã‚¸ãƒƒã‚¯ã‚’æŒãŸã›ã¦Commandã¨ã—ã¦æŒ¯ã‚‹èˆã‚ã›ã‚‹æ–¹æ³•ã¯ã€Javaã«ãŠã‘ã‚‹Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®éå¸¸ã«ã‚¹ãƒãƒ¼ãƒˆã§åŠ¹ç‡çš„ãªå®Ÿè£…ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆ**Enum Command Pattern** ã¨å‘¼ã°ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ï¼‰ã§ã™ã€‚

è‡ªä¿¡ã‚’æŒã£ã¦ã“ã®è¨­è¨ˆã‚’é€²ã‚ã¦ãã ã•ã„ã€‚

---

ğŸ§‘â€ğŸ’» ## USER

@app\src\main\java\io\github\sasori_256\town_planning\** ã“ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®å…¨ä½“ã‚’ã‚‚ã†ä¸€åº¦èª­ã¿è¾¼ã¿ç›´ã—ã¦ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ¡ˆã‚’è€ƒãˆã¦ãã ã•ã„
--- Content from referenced files ---
Content from @app\src\main\java\io\github\sasori_256\town_planning\App.java:
/*
 * This source file was generated by the Gradle 'init' task
 */
package io.github.sasori_256.town_planning;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());
    }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\controller\GameController.java:
package io.github.sasori_256.town_planning.controller;

import io.github.sasori_256.town_planning.model.GameModel;
import java.awt.geom.Point2D;

/**
 * å…¥åŠ›ã‚’å‡¦ç†ã—ã€ã‚²ãƒ¼ãƒ ãƒ¢ãƒ‡ãƒ«ã‚’åˆ¶å¾¡ã™ã‚‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ã€‚
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œï¼ˆãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯ã€ã‚­ãƒ¼å…¥åŠ›ï¼‰ã‚’ãƒ¢ãƒ‡ãƒ«ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«å¤‰æ›ã™ã‚‹ã€‚
 */
public class GameController {
  private final GameModel gameModel;

  public GameController(GameModel gameModel) {
    this.gameModel = gameModel;
  }

  public void onMapClicked(Point2D position) {
    // ãƒãƒƒãƒ—ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã¨ãã®å‡¦ç†
    // ä¾‹: å»ºç‰©å»ºè¨­ã€ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£é¸æŠãªã©
    System.out.println("Map clicked at: " + position);
    // ä»®ã®å®Ÿè£…: ã‚¯ãƒªãƒƒã‚¯ã—ãŸä½ç½®ã«ã‚½ã‚¦ãƒ«ã‚’è¿½åŠ ã—ã¦ã¿ã‚‹
    gameModel.addSouls(10);
  }
  
  public void startGame() {
      // æç”»ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯Appå´ã§è¨­å®šã™ã‚‹ã‹ã€ã‚ã‚‹ã„ã¯ã“ã“ã§Viewã‚’æ¸¡ã—ã¦ã‚‚ã‚‰ã†ã‹è¨­è¨ˆæ¬¡ç¬¬ã ãŒ
      // ã“ã“ã§ã¯ä¸€æ—¦nullã‚’æ¸¡ã—ã¦ãŠãï¼ˆã¾ã ViewãŒãªã„ãŸã‚ï¼‰ã€‚
      // å®Ÿéš›ã«ã¯Viewã®å†æç”»ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚‹ã€‚
      // gameModel.startGameLoop(() -> view.repaint());
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\controller\KeyInputHandler.java:

Content from @app\src\main\java\io\github\sasori_256\town_planning\core\GameContext.java:
package io.github.sasori_256.town_planning.core;

import io.github.sasori_256.town_planning.event.EventBus;
import io.github.sasori_256.town_planning.model.GameMap;
// Streamã¨ã¯
// Streamã¯ã€Java 8ã§å°å…¥ã•ã‚ŒãŸjava.util.streamãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å±ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€
// ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„é…åˆ—ãªã©ã®ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã«å¯¾ã—ã¦ã€é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§æ“ä½œã‚’è¡Œã†ãŸã‚ã®APIã‚’æä¾›ã—ã¾ã™ã€‚
// Streamã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€å¤‰æ›ã€é›†ç´„ãªã©ã®æ“ä½œã‚’ç°¡æ½”ã‹ã¤åŠ¹ç‡çš„ã«è¨˜è¿°ã§ãã¾ã™ã€‚
// Streamã¯ã€é…å»¶è©•ä¾¡ã‚’æ¡ç”¨ã—ã¦ãŠã‚Šã€å¿…è¦ãªã¨ãã«ã®ã¿ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã—ã¾ã™ã€‚
// ã“ã‚Œã«ã‚ˆã‚Šã€å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†éš›ã«ã‚‚åŠ¹ç‡çš„ãªå‡¦ç†ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚
// ã¾ãŸã€Streamã¯ä¸¦åˆ—å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åˆ©ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†ã‚’é«˜é€ŸåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
// Streamã¯ã€ä¸»ã«ä»¥ä¸‹ã®3ã¤ã®ã‚¹ãƒ†ãƒƒãƒ—ã§æ“ä½œã‚’è¡Œã„ã¾ã™ã€‚
// 1. ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ: ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„é…åˆ—ã‹ã‚‰Streamã‚’ç”Ÿæˆã—ã¾ã™ã€‚
// 2. ä¸­é–“æ“ä½œ: ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚„ãƒãƒƒãƒ”ãƒ³ã‚°ãªã©ã®æ“ä½œã‚’é€£é–çš„ã«é©ç”¨ã—ã¾ã™ã€‚
// 3. çµ‚ç«¯æ“ä½œ: é›†ç´„ã‚„åé›†ãªã©ã®æœ€çµ‚çš„ãªæ“ä½œã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
// ã“ã‚Œã«ã‚ˆã‚Šã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒå‘ä¸Šã—ã€è¤‡é›‘ãªãƒ‡ãƒ¼ã‚¿æ“ä½œã‚’ç°¡æ½”ã«è¡¨ç¾ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
import java.util.stream.Stream;

/**
 * ã‚²ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†ã«å¿…è¦ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’æä¾›ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€‚
 * DI (Dependency Injection) ã®ã‚ˆã†ãªå½¹å‰²ã‚’æœãŸã™ã€‚
 */
public interface GameContext {
  EventBus getEventBus();

  GameMap getMap();

  Stream<GameObject> getEntities();

  double getDeltaTime(); // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆç§’ï¼‰

  // Entity Lifecycle

  void spawnEntity(GameObject entity);

  void destroyEntity(GameObject entity);

}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\GameEntity.java:
package io.github.sasori_256.town_planning.core;

import java.awt.geom.Point2D;

/**
 * ã‚²ãƒ¼ãƒ ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’è¡¨ã™ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€‚
 * å„ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã¯ä¸€æ„ã®IDã¨ä½ç½®æƒ…å ±ã‚’æŒã¤ã€‚
 */
public interface GameEntity {
  String getId();

  Point2D getPosition();
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\GameLoop.java:
package io.github.sasori_256.town_planning.core;

// AtomicBooleanã«ã¤ã„ã¦
// AtomicBooleanã¯ã€Javaã®java.util.concurrent.atomicãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«å±ã™ã‚‹ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€
// ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªãƒ–ãƒ¼ãƒ«å€¤ã®æ“ä½œã‚’æä¾›ã—ã¾ã™ã€‚
// è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ–ãƒ¼ãƒ«å€¤ã‚’æ‰±ã†éš›ã«ä½¿ç”¨ã•ã‚Œã€
// ç«¶åˆçŠ¶æ…‹ã‚’é˜²ããŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚
// AtomicBooleanã¯ã€åŸºæœ¬çš„ãªãƒ–ãƒ¼ãƒ«å€¤ã®æ“ä½œï¼ˆtrue/falseã®è¨­å®šã€å–å¾—ã€åè»¢ãªã©ï¼‰ã‚’
// åŸå­æ“ä½œã¨ã—ã¦æä¾›ã—ã¾ã™ã€‚
// ã“ã‚Œã«ã‚ˆã‚Šã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«å€¤ã‚’å¤‰æ›´ã—ã‚ˆã†ã¨ã—ãŸå ´åˆã§ã‚‚ã€ä¸€è²«æ€§ãŒä¿ãŸã‚Œã¾ã™ã€‚
// ä¾‹ãˆã°ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã¾ãŸã¯ã‚¯ãƒªã‚¢ã—ã‚ˆã†ã¨ã™ã‚‹å ´åˆã«ã€
// AtomicBooleanã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ç«¶åˆçŠ¶æ…‹ã‚’é˜²ãã€æ­£ã—ã„çµæœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã®ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æä¾›ã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚
 * æ›´æ–°å‡¦ç†(Update)ã¨æç”»å‡¦ç†(Render)ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚
 */
public class GameLoop implements Runnable {
  private final AtomicBoolean running = new AtomicBoolean(false);
  private final Runnable updateCallback;
  private final Runnable renderCallback;
  private Thread thread = null;

  // 60 FPS target
  // TODO: ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ã‚’å®šæ•°åŒ–ã—ã¦å¤–éƒ¨ã‹ã‚‰å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
  private static final double TIME_STEP = 1.0 / 60.0;
  private static final long TIME_STEP_NANO = (long) (TIME_STEP * 1_000_000_000);

  public GameLoop(Runnable updateCallback, Runnable renderCallback) {
    this.updateCallback = updateCallback;
    this.renderCallback = renderCallback;
  }

  public void start() {
    if (thread == null) {
      try {
        if (running.compareAndSet(false, true)) {
          thread = new Thread(this, "GameLoop-Thread");
          thread.setDaemon(true); // ã‚¢ãƒ—ãƒªçµ‚äº†æ™‚ã«è‡ªå‹•ã§è½ã¡ã‚‹ã‚ˆã†ã«
          thread.start();
        }
      } catch (Exception e) {
        running.set(false);
        e.printStackTrace();
      }
    }
  }

  public void stop() {
    running.set(false);
    try {
      if (thread != null) {
        thread.join(); // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…æ©Ÿ
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      e.printStackTrace();
    }
  }

  @Override
  public void run() {
    long lastTime = System.nanoTime(); // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚åˆ»
    double accumulator = 0.0; // çµŒéæ™‚é–“

    while (running.get()) {
      long now = System.nanoTime();
      long frameTime = now - lastTime;
      lastTime = now;

      // ã‚ã¾ã‚Šã«å¤§ããªé…å»¶ãŒç™ºç”Ÿã—ãŸå ´åˆã®è£œæ­£
      // ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“ãŒ0.25ç§’ã‚’è¶…ãˆã‚‹å ´åˆã€0.25ç§’ã«åˆ¶é™ã™ã‚‹
      if (frameTime > 250_000_000) { // Max frame time to avoid spiral of death (0.25s)
        frameTime = 250_000_000;
      }

      accumulator += frameTime;

      // ä¿®æ­£ãƒ«ãƒ¼ãƒ—: å›ºå®šã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒƒãƒ—ã§æ›´æ–°ã‚’è¡Œã†
      while (accumulator >= TIME_STEP_NANO) {
        updateCallback.run();
        accumulator -= TIME_STEP_NANO;
      }

      // æç”»å‡¦ç†
      renderCallback.run();

      // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡: æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã¾ã§å¾…æ©Ÿ
      long sleepTime = (TIME_STEP_NANO - (System.nanoTime() - now)) / 1_000_000;
      if (sleepTime > 1) {
        try {
          Thread.sleep(sleepTime);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\GameObject.java:
package io.github.sasori_256.town_planning.core;

import io.github.sasori_256.town_planning.core.strategy.RenderStrategy;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * ã‚²ãƒ¼ãƒ å†…ã®å…¨ã¦ã®å‹•çš„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹ã€‚
 * Strategyãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”¨ã„ã¦æŒ¯ã‚‹èˆã„ã‚’å®šç¾©ã™ã‚‹ã€‚
 * ç¶™æ‰¿ã«ã‚ˆã‚‹æ‹¡å¼µã§ã¯ãªãã€ã‚³ãƒ³ãƒã‚¸ã‚·ãƒ§ãƒ³ï¼ˆStrategyï¼‰ã«ã‚ˆã‚‹æ©Ÿèƒ½è¿½åŠ ã‚’æ¨å¥¨ã™ã‚‹ã€‚
 */
public class GameObject implements GameEntity {
  private final String id;
  private Point2D position;

  // Strategies
  private UpdateStrategy updateStrategy;
  private RenderStrategy renderStrategy;

  // æ±ç”¨çš„ãªå±æ€§ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ (ECSã®Componentã®ç°¡æ˜“ç‰ˆ)
  private final Map<String, Object> attributes = new HashMap<>();

  public GameObject(Point2D position) {
    this.id = UUID.randomUUID().toString();
    this.position = position;
    // Default strategies (No-op)
    this.updateStrategy = (ctx, self) -> {
    };
    this.renderStrategy = (g, self) -> {
    };
  }

  @Override
  public String getId() {
    return id;
  }

  @Override
  public Point2D getPosition() {
    return position;
  }

  public void setPosition(Point2D position) {
    this.position = position;
  }

  public void setUpdateStrategy(UpdateStrategy updateStrategy) {
    this.updateStrategy = updateStrategy;
  }

  public void setRenderStrategy(RenderStrategy renderStrategy) {
    this.renderStrategy = renderStrategy;
  }

  public void update(GameContext context) {
    if (updateStrategy != null) {
      updateStrategy.update(context, this);
    }
  }

  public void render(Graphics2D g) {
    if (renderStrategy != null) {
      renderStrategy.render(g, this);
    }
  }

  public void setAttribute(String key, Object value) {
    attributes.put(key, value);
  }

  @SuppressWarnings("unchecked")
  public <T> T getAttribute(String key) {
    return (T) attributes.get(key);
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\Renderable.java:
package io.github.sasori_256.town_planning.core;

/**
 * æç”»å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€‚
 * å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è¡¨ç¤ºç”¨ã®ã‚·ãƒ³ãƒœãƒ«ã‚’æŒã¤(äºˆå®š)ã€‚
 */
public interface Renderable {
  String getDisplaySymbol();
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\Terrain.java:
package io.github.sasori_256.town_planning.core;

public interface Terrain {
  boolean isWalkable();

  boolean isBuildable();

  String getId();
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\Updatable.java:
package io.github.sasori_256.town_planning.core;

/**
 * ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°ã”ã¨ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€‚
 * ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚
 */
public interface Updatable {
  void tick();
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\strategy\RenderStrategy.java:
package io.github.sasori_256.town_planning.core.strategy;

import io.github.sasori_256.town_planning.core.GameObject;
import java.awt.Graphics2D;

@FunctionalInterface
public interface RenderStrategy {
  void render(Graphics2D g, GameObject self);
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\core\strategy\UpdateStrategy.java:
package io.github.sasori_256.town_planning.core.strategy;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.GameContext;

@FunctionalInterface
public interface UpdateStrategy {
  void update(GameContext context, GameObject self);
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\event\EventBus.java:
package io.github.sasori_256.town_planning.event;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

public class EventBus {
  private final Map<EventType, List<Consumer<Object>>> listeners = new ConcurrentHashMap<>();

  public void subscribe(EventType type, Consumer<Object> listener) {
    listeners.computeIfAbsent(type, k -> new ArrayList<>()).add(listener);
  }

  public void publish(EventType type, Object data) {
    List<Consumer<Object>> typeListeners = listeners.get(type);
    if (typeListeners != null) {
      typeListeners.forEach(l -> l.accept(data));
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\event\EventType.java:
package io.github.sasori_256.town_planning.event;

public enum EventType {
  MAP_UPDATED,
  SOUL_CHANGED,
  GAME_TICK,
  DAY_PASSED,
  RESIDENT_BORN,
  RESIDENT_DIED,
  SOUL_HARVESTED,
  DISASTER_OCCURRED
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\BuildingType.java:
package io.github.sasori_256.town_planning.model;

import java.awt.Color;

/**
 * å»ºç‰©ã®ç¨®é¡å®šç¾©ã€‚
 */
public enum BuildingType {
  HOUSE("ä½å±…", "H", Color.CYAN, 50, 4),
  CHURCH("æ•™ä¼š", "C", Color.YELLOW, 150, 0),
  GRAVEYARD("å¢“åœ°", "G", Color.GRAY, 100, 0);

  private final String displayName;
  private final String symbol;
  private final Color color;
  private final int cost;
  private final int capacity;

  BuildingType(String displayName, String symbol, Color color, int cost, int capacity) {
    this.displayName = displayName;
    this.symbol = symbol;
    this.color = color;
    this.cost = cost;
    this.capacity = capacity;
  }

  public String getDisplayName() {
    return displayName;
  }

  public String getSymbol() {
    return symbol;
  }

  public Color getColor() {
    return color;
  }

  public int getCost() {
    return cost;
  }

  public int getCapacity() {
    return capacity;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\DisasterType.java:
package io.github.sasori_256.town_planning.model;

/**
 * ç½å®³ã®ç¨®é¡å®šç¾©ã€‚
 */
public enum DisasterType {
  METEOR("éš•çŸ³", 200, 3, 100),
  PLAGUE("ç–«ç—…", 150, 5, 20);

  private final String displayName;
  private final int cost;
  private final int radius;
  private final int damage;

  DisasterType(String displayName, int cost, int radius, int damage) {
    this.displayName = displayName;
    this.cost = cost;
    this.radius = radius;
    this.damage = damage;
  }

  public String getDisplayName() {
    return displayName;
  }

  public int getCost() {
    return cost;
  }

  public int getRadius() {
    return radius;
  }

  public int getDamage() {
    return damage;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\GameMap.java:
package io.github.sasori_256.town_planning.model;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.event.*;
import java.awt.geom.Point2D;

public class GameMap {
  private final int width;
  private final int height;
  private final MapCell[][] cells;
  private final EventBus eventBus;

  public GameMap(int width, int height, EventBus eventBus) {
    this.width = width;
    this.height = height;
    this.eventBus = eventBus;
    this.cells = new MapCell[height][width];

    // Cellsã®åˆæœŸåŒ–
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        cells[y][x] = new MapCell(TerrainType.GRASS);
      }
    }
  }

  public boolean isValid(Point2D pos) {
    return pos.getX() >= 0 && pos.getX() < width
        && pos.getY() >= 0 && pos.getY() < height;
  }

  public MapCell getCell(Point2D pos) {
    if (!isValid(pos)) {
      // ç„¡åŠ¹ãªä½ç½®ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
      // ã¾ãŸã¯nullã‚’è¿”ã™ã€å¢ƒç•Œç”¨ã®ãƒ€ãƒŸãƒ¼ã‚»ãƒ«ã‚’è¿”ã™ãªã©ã®æ–¹æ³•ã‚‚è€ƒãˆã‚‰ã‚Œã‚‹
      throw new IndexOutOfBoundsException("Invalid position: " + pos);
    }
    return cells[(int) pos.getY()][(int) pos.getX()];
  }

  public boolean placeBuilding(Point2D.Float pos, GameObject building) {
    if (!isValid(pos)) {
      return false;
    }
    MapCell cell = getCell(pos);
    if (cell.canBuild()) {
      cell.setBuilding(building);
      eventBus.publish(EventType.MAP_UPDATED, pos);
      return true;
    }
    return false;
  }

  public boolean removeBuilding(Point2D.Float pos) {
    if (!isValid(pos)) {
      return false;
    }
    MapCell cell = getCell(pos);
    if (cell.getBuilding().isPresent()) {
      cell.removeBuilding();
      eventBus.publish(EventType.MAP_UPDATED, pos);
      return true;
    }
    return false;
  }

  public int getWidth() {
    return width;
  }

  public int getHeight() {
    return height;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\GameModel.java:
package io.github.sasori_256.town_planning.model;

import io.github.sasori_256.town_planning.core.*;
import io.github.sasori_256.town_planning.event.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Stream;

/**
 * ã‚²ãƒ¼ãƒ ã®å…¨ä½“ãƒ¢ãƒ‡ãƒ«ã€‚
 * GameContextã®å®Ÿè£…ã§ã‚ã‚Šã€GameLoopã®ãƒ›ã‚¹ãƒˆã§ã‚‚ã‚ã‚‹ã€‚
 */
public class GameModel implements GameContext, Updatable {
  private final EventBus eventBus;
  private final GameMap gameMap;
  private final GameLoop gameLoop;

  // ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ï¼ˆæ›´æ–°ã‚¹ãƒ¬ãƒƒãƒ‰ã¨æç”»ã‚¹ãƒ¬ãƒƒãƒ‰/UIã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒã‚ã‚‹ãŸã‚ï¼‰
  private final List<GameObject> entities = new CopyOnWriteArrayList<>();

  private int souls = 100;
  private int day = 1;
  private double dayTimer = 0;
  private static final double DAY_LENGTH = 10.0; // 10ç§’ã§1æ—¥

  private double lastDeltaTime = 0;

  public GameModel(EventBus eventBus) {

    this.eventBus = eventBus;

    // ãƒãƒƒãƒ—ã‚µã‚¤ã‚º 100x100 (ä»®)

    this.gameMap = new GameMap(100, 100, eventBus);

    // Event Subscriptions

    this.eventBus.subscribe(EventType.SOUL_HARVESTED, data -> {

      if (data instanceof Integer) {

        addSouls((Integer) data);

      }

    });

    // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

    // Updateã¯this.tick()ã€Renderã¯Viewå´ã§è¡Œã†ãŒã€
    // GameLoopã¯Runnableã‚’å—ã‘å–ã‚‹ã®ã§ã€Viewã¸ã®é€šçŸ¥ã¯EventBusçµŒç”±ã‹Callbackã§è¡Œã†å¿…è¦ãŒã‚ã‚‹ã€‚
    // ä»Šå›ã¯å˜ç´”åŒ–ã®ãŸã‚ã€GameModelã¯Updateã®ã¿ã‚’ãƒ«ãƒ¼ãƒ—ã§å›ã—ã€Renderæ›´æ–°é€šçŸ¥ã‚’EventBusã§æŠ•ã’ã‚‹å½¢ã«ã™ã‚‹ã‹ã€
    // ã‚ã‚‹ã„ã¯ViewãŒGameLoopã®RenderCallbackã‚’ç™»éŒ²ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
    // ã“ã“ã§ã¯ã€GameModelãŒãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†ã—ã€Viewæ›´æ–°ç”¨Callbackã‚’å—ã‘å–ã‚Œã‚‹ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã€‚

    this.gameLoop = new GameLoop(this::tick, () -> {
      // Render Trigger (Viewå´ã§è³¼èª­ã™ã‚‹ã‹ã€å°‚ç”¨ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‘¼ã¶)
      // ä»Šå›ã¯EventBusã ã¨é«˜é »åº¦ã™ãã‚‹ã‹ã‚‚ã—ã‚Œãªã„ãŒã€ä¸€æ—¦ä¿ç•™ã€‚
      // é€šå¸¸ã€Viewã¯ repaint() ã‚’å‘¼ã³å‡ºã™ Runnable ã‚’æ¸¡ã™ã€‚
    });
  }

  public void startGameLoop(Runnable renderCallback) {
    // æ—¢å­˜ã®ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚Šç›´ã™å¿…è¦ãŒã‚ã‚‹ï¼ˆRenderCallbackã‚’æ³¨å…¥ã™ã‚‹ãŸã‚ï¼‰
    // ã¾ãŸã¯GameLoopã‚’å°‘ã—æ”¹é€ ã—ã¦setterã‚’ã¤ã‘ã‚‹ã€‚
    // ã“ã“ã§ã¯æ–°ã—ã„GameLoopã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œã‚‹ç°¡æ˜“å®Ÿè£…ã€‚
    GameLoop loop = new GameLoop(this::tick, renderCallback);
    loop.start();
  }

  @Override
  public void tick() {
    // æ™‚é–“è¨ˆæ¸¬ (ç°¡æ˜“çš„)
    double dt = 1.0 / 60.0; // Fixed time step
    this.lastDeltaTime = dt;

    // æ™‚é–“çµŒéå‡¦ç†
    dayTimer += dt;
    if (dayTimer >= DAY_LENGTH) {
      dayTimer = 0;
      day++;
      eventBus.publish(EventType.DAY_PASSED, day);
    }

    // å…¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®æ›´æ–°
    for (GameObject entity : entities) {
      entity.update(this);
    }
  }

  // --- GameContext Implementation ---

  @Override
  public EventBus getEventBus() {
    return eventBus;
  }

  @Override
  public GameMap getMap() {
    return gameMap;
  }

  @Override
  public Stream<GameObject> getEntities() {
    return entities.stream();
  }

  @Override
  public double getDeltaTime() {
    return lastDeltaTime;
  }

  @Override
  public void spawnEntity(GameObject entity) {
    addEntity(entity);
  }

  @Override
  public void destroyEntity(GameObject entity) {
    removeEntity(entity);
  }

  // --- Game Logic API ---

  public void addEntity(GameObject entity) {
    entities.add(entity);
    eventBus.publish(EventType.MAP_UPDATED, entity.getPosition());
  }

  public void removeEntity(GameObject entity) {
    entities.remove(entity);
    // ãƒãƒƒãƒ—ä¸Šã®å æœ‰æƒ…å ±ãªã©ã‚‚ã‚¯ãƒªã‚¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãªã‚‰MapçµŒç”±ã§è¡Œã†
    eventBus.publish(EventType.MAP_UPDATED, entity.getPosition());
  }

  public int getSouls() {
    return souls;
  }

  public void addSouls(int amount) {

    this.souls += amount;

    eventBus.publish(EventType.SOUL_CHANGED, souls);

  }

  /**
   * 
   * æŒ‡å®šåº§æ¨™ä»˜è¿‘ã®æ­»ä½“ã‹ã‚‰é­‚ã‚’åˆˆã‚Šå–ã‚‹ã€‚
   * 
   * @param pos ã‚¯ãƒªãƒƒã‚¯åº§æ¨™
   * 
   * @return åˆˆã‚Šå–ã‚Šã«æˆåŠŸã—ãŸã‚‰true
   * 
   */

  public boolean harvestSoulAt(java.awt.geom.Point2D pos) {

    double harvestRadius = 1.0; // åŠå¾„1ã‚°ãƒªãƒƒãƒ‰

    // ç¯„å›²å†…ã®æ­»ä½“ã‚’æ¢ã™

    // Note: è¤‡æ•°ã®æ­»ä½“ãŒé‡ãªã£ã¦ã„ã‚‹å ´åˆã€1ã¤ã ã‘å›åã™ã‚‹ã‹å…¨éƒ¨å›åã™ã‚‹ã‹ã¯ä»•æ§˜æ¬¡ç¬¬ã€‚

    // ã“ã“ã§ã¯æœ€åˆã«è¦‹ã¤ã‹ã£ãŸ1ã¤ã‚’å›åã™ã‚‹ã€‚

    java.util.Optional<GameObject> target = entities.stream()

        .filter(e -> {

          ResidentAttributes.State state = e.getAttribute(ResidentAttributes.State.STATE); // STATEã‚­ãƒ¼ãŒ"state"æ–‡å­—åˆ—ã¨é‡è¤‡æ³¨æ„ã€‚ResidentAttributes.STATEå®šæ•°ã‚’ä½¿ã†ã€‚

          // Attributeã‚­ãƒ¼ã¯Stringãªã®ã§ã€ResidentAttributes.STATE (="state") ã‚’ä½¿ã†ã€‚

          // getAttributeã®æˆ»ã‚Šå€¤ã¯Enumã€‚

          Object stateObj = e.getAttribute(ResidentAttributes.STATE);

          return stateObj == ResidentAttributes.State.DEAD;

        })

        .filter(e -> e.getPosition().distance(pos) <= harvestRadius)

        .findFirst();

    if (target.isPresent()) {

      GameObject soul = target.get();

      // é­‚å›å

      int soulAmount = 10; // ä»®: ä½æ°‘ã®ç¨®é¡ã‚„ä¿¡ä»°å¿ƒã«ã‚ˆã£ã¦å¤‰å‹•ã•ã›ã‚‹ã¨ãªãŠè‰¯ã„

      // ä¿¡ä»°å¿ƒãƒœãƒ¼ãƒŠã‚¹è¨ˆç®— (ä¾‹)

      Integer faith = soul.getAttribute(ResidentAttributes.FAITH);

      if (faith != null) {

        soulAmount += faith / 5;

      }

      eventBus.publish(EventType.SOUL_HARVESTED, soulAmount);

      destroyEntity(soul);

      return true;

    }

    return false;

  }

  /**
   * 
   * å»ºç‰©ã‚’å»ºè¨­ã™ã‚‹ã€‚
   * 
   * @param type å»ºç‰©ã®ç¨®é¡
   * 
   * @param pos  å»ºè¨­ä½ç½®ï¼ˆã‚°ãƒªãƒƒãƒ‰åº§æ¨™ï¼‰
   * 
   * @return å»ºè¨­ã«æˆåŠŸã—ãŸã‚‰true
   * 
   */

  public boolean constructBuilding(BuildingType type, java.awt.geom.Point2D pos) {

    // 1. ã‚³ã‚¹ãƒˆãƒã‚§ãƒƒã‚¯

    if (souls < type.getCost()) {

      return false;

    }

    // 2. ãƒãƒƒãƒ—ä¸Šã®å»ºè¨­å¯å¦ãƒã‚§ãƒƒã‚¯

    // GameMap.placeBuildingå†…ã§ãƒã‚§ãƒƒã‚¯ã•ã‚Œã‚‹ãŒã€ã“ã“ã§ã¯äº‹å‰ã«ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚³ã‚¹ãƒˆæ¶ˆè²»ã‚’åˆ¶å¾¡ã™ã‚‹

    if (!gameMap.isValid(pos) || !gameMap.getCell(pos).canBuild()) {

      return false;

    }

    // 3. å»ºè¨­å‡¦ç†

    // é­‚æ¶ˆè²»

    addSouls(-type.getCost());

    // GameObjectç”Ÿæˆ

    GameObject building = new GameObject(pos);

    // Strategyè¨­å®š

    building.setRenderStrategy(
        io.github.sasori_256.town_planning.model.strategy.SimpleRenderStrategy.fromBuildingType(type));

    // å»ºç‰©ã”ã¨ã®å›ºæœ‰ãƒ­ã‚¸ãƒƒã‚¯

    if (type == BuildingType.HOUSE) {

      building.setUpdateStrategy(
          new io.github.sasori_256.town_planning.model.strategy.PopulationGrowthStrategy(type.getCapacity()));

    }

    // ãƒãƒƒãƒ—ã¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãƒªã‚¹ãƒˆã¸ã®ç™»éŒ²

    // Note: placeBuildingã¯MapCellã¸ã®ç™»éŒ²ã®ã¿ã‚’è¡Œã†ã€‚Entityãƒªã‚¹ãƒˆã¸ã®ç™»éŒ²ã¯åˆ¥é€”å¿…è¦ã€‚

    // ã¾ãŸã€GameObjectã¨GameEntityã®æ•´åˆæ€§ã‚’ä¿ã¤ãŸã‚ã€GameMapã¯GameObjectã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ä¿®æ­£ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œãªã„ãŒã€

    // ç¾çŠ¶ã¯GameMapã¯GameEntityã‚’å—ã‘å–ã‚‹ã€‚GameObjectã¯GameEntityã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã®ã§OKã€‚

    if (gameMap.placeBuilding(pos, building)) {

      addEntity(building);

      return true;

    } else {

      // ä¸‡ãŒä¸€Mapã¸ã®é…ç½®ã«å¤±æ•—ã—ãŸå ´åˆã¯æ‰•ã„æˆ»ã—ï¼ˆé€šå¸¸ã“ã“ã«ã¯æ¥ãªã„ã¯ãšï¼‰

      addSouls(type.getCost());

      return false;

    }

  }

  public int getDay() {

    return day;

  }

}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\MapCell.java:
package io.github.sasori_256.town_planning.model;

import io.github.sasori_256.town_planning.core.GameEntity;
import io.github.sasori_256.town_planning.core.Terrain;
import java.util.Optional;

public class MapCell {
  private Terrain terrain;
  private GameEntity building;

  public MapCell(Terrain initTerrain) {
    this.terrain = initTerrain;
    this.building = null;
  }

  public Terrain getTerrain() {
    return terrain;
  }

  public boolean setTerrain(Terrain terrain) {
    this.terrain = terrain;
    return true;
  }

  public Optional<GameEntity> getBuilding() {
    return Optional.ofNullable(building);
  }

  public boolean setBuilding(GameEntity building) {
    this.building = building;
    return true;
  }

  public boolean removeBuilding() {
    this.building = null;
    return true;
  }

  public boolean canBuild() {
    return terrain.isBuildable() && building == null;
  }

  public boolean canWalk() {
    boolean terrainOk = terrain.isWalkable();
    boolean buildingOk = (building == null);
    return terrainOk && buildingOk;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\ResidentAttributes.java:
package io.github.sasori_256.town_planning.model;

/**
 * GameObjectã®å±æ€§ãƒãƒƒãƒ—ã§ä½¿ç”¨ã™ã‚‹ã‚­ãƒ¼å®šæ•°ã€‚
 */
public class ResidentAttributes {
  // åŸºæœ¬ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
  public static final String TYPE = "resident_type"; // ResidentType enum
  public static final String AGE = "age"; // Double (years/days)
  public static final String MAX_AGE = "max_age"; // Double
  public static final String FAITH = "faith"; // Integer (0-100)
  public static final String STATE = "state"; // ResidentState enum

  // çŠ¶æ…‹å®šç¾©
  public enum State {
    ALIVE,
    DEAD,
    SOUL_HARVESTED
  }

  private ResidentAttributes() {
  } // Prevent instantiation
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\ResidentType.java:
package io.github.sasori_256.town_planning.model;

/**
 * ä½æ°‘ã®å±æ€§å®šç¾©ã€‚
 */
public enum ResidentType {
  CIVILIAN("ä¸€èˆ¬äºº", 1.0f),
  BELIEVER("ä¿¡è€…", 1.5f),
  HERETIC("ç•°ç«¯è€…", 0.5f);

  private final String displayName;
  private final float faithMultiplier;

  ResidentType(String displayName, float faithMultiplier) {
    this.displayName = displayName;
    this.faithMultiplier = faithMultiplier;
  }

  public String getDisplayName() {
    return displayName;
  }

  public float getFaithMultiplier() {
    return faithMultiplier;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\TerrainType.java:
package io.github.sasori_256.town_planning.model;

import io.github.sasori_256.town_planning.core.Terrain;

public enum TerrainType implements Terrain {
  GRASS(true, true, "Grass"),
  WATER(false, false, "Water"),
  MOUNTAIN(false, false, "Mountain"),
  ROAD(true, false, "Road");

  private final boolean walkable;
  private final boolean buildable;
  private final String id;

  TerrainType(boolean walkable, boolean buildable, String id) {
    this.walkable = walkable;
    this.buildable = buildable;
    this.id = id;
  }

  @Override
  public boolean isWalkable() {
    return walkable;
  }

  @Override
  public boolean isBuildable() {
    return buildable;
  }

  @Override
  public String getId() {
    return id;
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\CompositeUpdateStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameContext;
import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import java.util.Arrays;
import java.util.List;

/**
 * è¤‡æ•°ã®UpdateStrategyã‚’é †ç•ªã«å®Ÿè¡Œã™ã‚‹ã‚³ãƒ³ãƒã‚¸ãƒƒãƒˆæˆ¦ç•¥ã€‚
 */
public class CompositeUpdateStrategy implements UpdateStrategy {
  private final List<UpdateStrategy> strategies;

  public CompositeUpdateStrategy(UpdateStrategy... strategies) {
    this.strategies = Arrays.asList(strategies);
  }

  @Override
  public void update(GameContext context, GameObject self) {
    for (UpdateStrategy strategy : strategies) {
      strategy.update(context, self);
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\MeteorDisasterStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameContext;
import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.RenderStrategy;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import io.github.sasori_256.town_planning.event.EventType;
import io.github.sasori_256.town_planning.model.DisasterType;
import io.github.sasori_256.town_planning.model.ResidentAttributes;
import io.github.sasori_256.town_planning.model.ResidentAttributes.State;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.util.List;
import java.util.stream.Collectors;

/**
 * éš•çŸ³ãªã©ã®å˜ç™ºç½å®³ã®ãƒ­ã‚¸ãƒƒã‚¯ã€‚
 * ç”Ÿæˆã•ã‚Œã¦ã‹ã‚‰ä¸€å®šæ™‚é–“å¾Œã«ç€å¼¾ã—ã€ç¯„å›²ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹ã€‚
 */
public class MeteorDisasterStrategy implements UpdateStrategy, RenderStrategy {
  private final DisasterType type;
  private final Point2D targetPos;
  private double timer = 0;
  private final double impactTime = 2.0; // 2ç§’å¾Œã«ç€å¼¾
  private boolean impacted = false;

  public MeteorDisasterStrategy(DisasterType type, Point2D targetPos) {
    this.type = type;
    this.targetPos = targetPos;
  }

  @Override
  public void update(GameContext context, GameObject self) {
    if (impacted) {
      // ç€å¼¾å¾Œã®ä½™éŸ»ï¼ˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ¶ˆæ»…å¾…ã¡ãªã©ï¼‰
      timer += context.getDeltaTime();
      if (timer > impactTime + 1.0) { // ç€å¼¾å¾Œ1ç§’ã§æ¶ˆæ»…
        context.destroyEntity(self);
      }
      return;
    }

    timer += context.getDeltaTime();

    // ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (ç©ºã‹ã‚‰é™ã£ã¦ãã‚‹)
    double progress = timer / impactTime;
    double startY = -10.0; // ç”»é¢å¤–ä¸Šç©º
    double currentY = startY + (targetPos.getY() - startY) * progress;
    self.setPosition(new Point2D.Double(targetPos.getX(), currentY));

    if (timer >= impactTime) {
      impact(context, self);
    }
  }

  private void impact(GameContext context, GameObject self) {
    impacted = true;
    self.setPosition(targetPos);

    // ç¯„å›²å†…ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æ¤œç´¢
    List<GameObject> targets = context.getEntities()
        .filter(e -> e != null && e.getPosition().distance(targetPos) <= type.getRadius())
        .collect(Collectors.toList());

    for (GameObject target : targets) {
      // ä½æ°‘ã¸ã®å‡¦ç†
      State state = target.getAttribute(ResidentAttributes.STATE);
      if (state == State.ALIVE) {
        // å³æ­»ã•ã›ã‚‹
        target.setAttribute(ResidentAttributes.STATE, State.DEAD);
        context.getEventBus().publish(EventType.RESIDENT_DIED, target);

        // ç½å®³ã«ã‚ˆã‚‹æ­»äº¡ã¯é­‚ã‚’å³æ™‚å›åã§ãã‚‹ãƒœãƒ¼ãƒŠã‚¹ãŒã‚ã‚‹ã‹ã‚‚ï¼Ÿ
        // ã“ã“ã§ã¯å˜ç´”ã«æ­»äº¡ã•ã›ã‚‹ã®ã¿ã¨ã—ã€å›åã¯åˆ¥é€”ã‚¯ãƒªãƒƒã‚¯ç­‰ã§è¡Œã†ã‹ã€
        // ã‚ã‚‹ã„ã¯ã€Œåˆˆã‚Šå–ã‚‹ã€ç½å®³ãªã‚‰ã“ã“ã§å›åã‚¤ãƒ™ãƒ³ãƒˆã‚’æŠ•ã’ã‚‹ã€‚
        // ä»Šå›ã¯ã€Œéš•çŸ³ã§æ­»ã¬ -> æ­»ä½“ã«ãªã‚‹ã€ã ã‘ã«ã™ã‚‹ã€‚
      }

      // å»ºç‰©ã¸ã®å‡¦ç† (å±æ€§ãƒã‚§ãƒƒã‚¯ãªã©ã§åˆ¤å®š)
      // String buildingType = target.getAttribute("building_type");
      // if (buildingType != null) { ... }
    }

    context.getEventBus().publish(EventType.DISASTER_OCCURRED, type);
  }

  @Override
  public void render(Graphics2D g, GameObject self) {
    Point2D pos = self.getPosition();
    int x = (int) (pos.getX() * 32);
    int y = (int) (pos.getY() * 32);
    int radiusPx = type.getRadius() * 32;

    if (!impacted) {
      // è½ä¸‹ä¸­ã®éš•çŸ³
      g.setColor(Color.RED);
      g.fillOval(x - 10, y - 10, 20, 20);

      // è½ä¸‹åœ°ç‚¹äºˆæ¸¬
      Point2D target = this.targetPos;
      int tx = (int) (target.getX() * 32);
      int ty = (int) (target.getY() * 32);
      g.setColor(new Color(255, 0, 0, 50));
      g.drawOval(tx - radiusPx, ty - radiusPx, radiusPx * 2, radiusPx * 2);
    } else {
      // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      g.setColor(new Color(255, 100, 0, 150)); // Orange
      g.fillOval(x - radiusPx, y - radiusPx, radiusPx * 2, radiusPx * 2);
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\PopulationGrowthStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameContext;
import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import io.github.sasori_256.town_planning.event.EventType;
import io.github.sasori_256.town_planning.model.BuildingType;
import io.github.sasori_256.town_planning.model.ResidentAttributes;
import io.github.sasori_256.town_planning.model.ResidentType;
import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.concurrent.ThreadLocalRandom;

/**
 * ä½å±…ã®æ©Ÿèƒ½ï¼šäººå£å¢—åŠ ã€‚
 * ä¸€å®šæ™‚é–“ã”ã¨ã«æ–°ã—ã„ä½æ°‘ã‚’ç”Ÿæˆã™ã‚‹ã€‚
 */
public class PopulationGrowthStrategy implements UpdateStrategy {
  private final int maxCapacity;
  private double timer = 0;
  private final double spawnInterval = 15.0; // 15ç§’ã”ã¨ã«åˆ¤å®š
  private int currentPopulation = 0; // ã“ã®å®¶ãŒç”Ÿæˆã—ãŸï¼ˆç®¡ç†ã—ã¦ã„ã‚‹ï¼‰ä½æ°‘æ•°

  public PopulationGrowthStrategy(int maxCapacity) {
    this.maxCapacity = maxCapacity;
  }

  @Override
  public void update(GameContext context, GameObject self) {
    if (currentPopulation >= maxCapacity) {
      return;
    }

    timer += context.getDeltaTime();
    if (timer >= spawnInterval) {
      timer = 0;
      // 50%ã®ç¢ºç‡ã§ä½æ°‘ç”Ÿæˆ
      if (ThreadLocalRandom.current().nextBoolean()) {
        spawnResident(context, self.getPosition());
        currentPopulation++;
      }
    }
  }

  private void spawnResident(GameContext context, Point2D spawnPos) {
    GameObject resident = new GameObject(spawnPos);

    // å±æ€§è¨­å®š
    resident.setAttribute(ResidentAttributes.TYPE, ResidentType.CIVILIAN);
    resident.setAttribute(ResidentAttributes.AGE, 0.0);
    resident.setAttribute(ResidentAttributes.MAX_AGE, (double) ThreadLocalRandom.current().nextInt(60, 100)); // å¯¿å‘½60-100
    resident.setAttribute(ResidentAttributes.STATE, ResidentAttributes.State.ALIVE);
    resident.setAttribute(ResidentAttributes.FAITH, 10);

    // Strategyè¨­å®š
    resident.setUpdateStrategy(new CompositeUpdateStrategy(
        new RandomMoveStrategy(),
        new ResidentLifeCycleStrategy()));

    // ç”Ÿå­˜æ™‚ã®è¦‹ãŸç›®
    SimpleRenderStrategy aliveVisual = new SimpleRenderStrategy(Color.ORANGE, "R", 20);
    // çŠ¶æ…‹ã«ã‚ˆã£ã¦åˆ‡ã‚Šæ›¿ãˆã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼
    resident.setRenderStrategy(new ResidentRenderStrategy(aliveVisual));

    context.spawnEntity(resident);
    context.getEventBus().publish(EventType.RESIDENT_BORN, resident);
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\RandomMoveStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameContext;
import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import java.awt.geom.Point2D;
import java.util.concurrent.ThreadLocalRandom;

/**
 * ãƒ©ãƒ³ãƒ€ãƒ ã«ç§»å‹•ã™ã‚‹Strategyã€‚
 */
public class RandomMoveStrategy implements UpdateStrategy {
  private double moveTimer = 0;
  private final double moveInterval = 1.0; // 1ç§’ã”ã¨ã«ç§»å‹•æ–¹å‘ã‚’å¤‰ãˆã‚‹
  private double dx = 0;
  private double dy = 0;
  private final double speed = 2.0; // ãƒ”ã‚¯ã‚»ãƒ«/ç§’ (ã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ãªã‚‰èª¿æ•´ãŒå¿…è¦)

  @Override
  public void update(GameContext context, GameObject self) {
    double dt = context.getDeltaTime();
    moveTimer += dt;

    if (moveTimer >= moveInterval) {
      moveTimer = 0;
      // æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ (-1.0 ~ 1.0)
      dx = ThreadLocalRandom.current().nextDouble(-1, 1);
      dy = ThreadLocalRandom.current().nextDouble(-1, 1);
    }

    // ç§»å‹•å‡¦ç†
    Point2D current = self.getPosition();
    double nextX = current.getX() + dx * speed * dt;
    double nextY = current.getY() + dy * speed * dt;

    // ãƒãƒƒãƒ—å¢ƒç•Œãƒã‚§ãƒƒã‚¯ (ç°¡æ˜“)
    if (context.getMap().isValid(new Point2D.Double(nextX, nextY))) {
      self.setPosition(new Point2D.Double(nextX, nextY));
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\ResidentLifeCycleStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameContext;
import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;
import io.github.sasori_256.town_planning.event.EventType;
import io.github.sasori_256.town_planning.model.ResidentAttributes;
import io.github.sasori_256.town_planning.model.ResidentAttributes.State;

/**
 * ä½æ°‘ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ï¼ˆåŠ é½¢ã€æ­»äº¡ï¼‰ã‚’ç®¡ç†ã™ã‚‹Strategyã€‚
 */
public class ResidentLifeCycleStrategy implements UpdateStrategy {

  @Override
  public void update(GameContext context, GameObject self) {
    State state = self.getAttribute(ResidentAttributes.STATE);
    if (state != State.ALIVE) {
      return; // ç”Ÿãã¦ãªã‘ã‚Œã°åŠ é½¢ã—ãªã„ï¼ˆæ­»ä½“å‡¦ç†ã¯åˆ¥é€”ï¼‰
    }

    double dt = context.getDeltaTime();

    // å¹´é½¢å–å¾—ã¨åŠ é½¢
    Double currentAge = self.getAttribute(ResidentAttributes.AGE);
    if (currentAge == null)
      currentAge = 0.0;

    // 1æ—¥ = 1æ­³ ã¨ã™ã‚‹è¨­å®šï¼ˆä»®ï¼‰
    // GameContextã‹ã‚‰1æ—¥ã®é•·ã•ã‚’å–å¾—ã§ããªã„ãŸã‚ã€dtã‚’ãã®ã¾ã¾åŠ ç®—ã—ã€
    // GameModelå´ã®Dayæ›ç®—ã«ä¾å­˜ã™ã‚‹ã‹ã€ã“ã“ã§ç‹¬è‡ªã«è¨ˆç®—ã™ã‚‹ã‹ã€‚
    // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã« dt ã‚’æ™‚é–“ã¨ã—ã¦åŠ ç®—ã™ã‚‹ã€‚
    // ãƒãƒ©ãƒ³ã‚¹èª¿æ•´: 10ç§’ã§1æ—¥(GameModelè¨­å®š) -> 10ç§’ã§1æ­³ã¨ä»®å®š
    double agingRate = 1.0 / 10.0; // 1ç§’ã§0.1æ­³
    double newAge = currentAge + (dt * agingRate);

    self.setAttribute(ResidentAttributes.AGE, newAge);

    // å¯¿å‘½ãƒã‚§ãƒƒã‚¯
    Double maxAge = self.getAttribute(ResidentAttributes.MAX_AGE);
    if (maxAge != null && newAge >= maxAge) {
      die(context, self);
    }
  }

  private void die(GameContext context, GameObject self) {
    self.setAttribute(ResidentAttributes.STATE, State.DEAD);

    // æ­»äº¡ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ (ãƒ­ã‚°è¡¨ç¤ºã‚„åŠ¹æœéŸ³ç”¨)
    context.getEventBus().publish(EventType.RESIDENT_DIED, self);

    // è¦‹ãŸç›®ã‚’å¤‰ãˆã‚‹ãŸã‚ã«RenderStrategyã‚’å¤‰æ›´ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ãªã©ã‚’ã“ã“ã«æŒŸã‚€ã“ã¨ã‚‚å¯èƒ½
    // ä¾‹: self.setRenderStrategy(new DeadBodyRenderStrategy());

    // ä¸€æ—¦ã€ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œæ­»ã‚“ã ã‚‰å³åº§ã«é­‚ã«ãªã‚‹ã€è‡ªå‹•å›åãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹ã‹ã€
    // ã‚ã‚‹ã„ã¯ã€Œæ­»ä½“ã¨ã—ã¦æ®‹ã‚Šã€ã‚¯ãƒªãƒƒã‚¯ã§å›åã€ã«ã™ã‚‹ã‹ã€‚
    // GDDã«ã¯ã€Œä½äººã®å‘½ã‚’åˆˆã‚Šå–ã‚Š...ã€ã¨ã‚ã‚‹ã®ã§ã€èƒ½å‹•çš„ã‚ã‚‹ã„ã¯ç½å®³ã§æ­»ã¬ã€‚
    // è‡ªç„¶æ­»ã®å ´åˆã¯è‡ªå‹•å›åã§ã‚‚ã‚ˆã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚

    // ä»®å®Ÿè£…: è‡ªç„¶æ­»ã¯å³åº§ã«æ¶ˆæ»…ã—ã€å°‘é‡ã®é­‚ã‚’é‚„å…ƒã™ã‚‹
    // (GameModelã¸ã®ã‚­ãƒ£ã‚¹ãƒˆãŒå¿…è¦ãªã®ãŒè¨­è¨ˆä¸Šã®èª²é¡Œã ãŒã€EventBusã§è§£æ±ºã™ã‚‹)
    // context.getEventBus().publish(EventType.SOUL_HARVESTED, 10);
    // context.destroyEntity(self);

    // ä»Šå›ã¯ã€Œæ­»ä½“ã€çŠ¶æ…‹ã®ã¾ã¾æ®‹ã™ã“ã¨ã«ã™ã‚‹ã€‚
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\ResidentRenderStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.RenderStrategy;
import io.github.sasori_256.town_planning.model.ResidentAttributes;
import io.github.sasori_256.town_planning.model.ResidentAttributes.State;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;

/**
 * ä½æ°‘ã®çŠ¶æ…‹ã«å¿œã˜ã¦è¦‹ãŸç›®ã‚’å¤‰ãˆã‚‹æç”»Strategyã€‚
 * ç”Ÿå­˜æ™‚ã€æ­»äº¡æ™‚ã§è‰²ã‚„å½¢ã‚’å¤‰ãˆã‚‹ã€‚
 */
public class ResidentRenderStrategy implements RenderStrategy {
  private final RenderStrategy aliveStrategy;

  public ResidentRenderStrategy(RenderStrategy aliveStrategy) {
    this.aliveStrategy = aliveStrategy;
  }

  @Override
  public void render(Graphics2D g, GameObject self) {
    State state = self.getAttribute(ResidentAttributes.STATE);

    if (state == State.DEAD) {
      // æ­»ä½“ã®æç”»
      Point2D pos = self.getPosition();
      int x = (int) (pos.getX() * 32);
      int y = (int) (pos.getY() * 32);

      g.setColor(Color.GRAY);
      g.fillOval(x + 4, y + 8, 24, 16); // æ¨ªãŸã‚ã£ã¦ã„ã‚‹ã‚ˆã†ãªæ¥•å††
      g.setColor(Color.BLACK);
      g.drawString("â€ ", x + 10, y + 20);
    } else {
      // ç”Ÿå­˜æ™‚ã®æç”»ï¼ˆå§”è­²ï¼‰
      aliveStrategy.render(g, self);
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\model\strategy\SimpleRenderStrategy.java:
package io.github.sasori_256.town_planning.model.strategy;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.core.strategy.RenderStrategy;
import io.github.sasori_256.town_planning.model.BuildingType;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Point2D;

/**
 * å˜ç´”ãªå›³å½¢ã¨ã—ã¦æç”»ã™ã‚‹Strategyã€‚
 */
public class SimpleRenderStrategy implements RenderStrategy {
  private final Color color;
  private final String symbol;
  private final int size;

  public SimpleRenderStrategy(Color color, String symbol, int size) {
    this.color = color;
    this.symbol = symbol;
    this.size = size;
  }

  public static SimpleRenderStrategy fromBuildingType(BuildingType type) {
    return new SimpleRenderStrategy(type.getColor(), type.getSymbol(), 32); // 32x32 size
  }

  @Override
  public void render(Graphics2D g, GameObject self) {
    Point2D pos = self.getPosition();
    int x = (int) pos.getX() * 32; // ã‚°ãƒªãƒƒãƒ‰åº§æ¨™ -> ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™å¤‰æ› (ä»®: 1ã‚°ãƒªãƒƒãƒ‰=32px)
    int y = (int) pos.getY() * 32;

    // æœ¬æ¥ã¯Cameraã‚¯ãƒ©ã‚¹ãªã©ã‚’é€šã—ã¦åº§æ¨™å¤‰æ›ã™ã¹ãã ãŒã€ä¸€æ—¦ç›´æ›¸ã

    g.setColor(color);
    g.fillRect(x, y, size, size);

    g.setColor(Color.BLACK);
    g.drawRect(x, y, size, size);

    if (symbol != null) {
      g.drawString(symbol, x + size / 4, y + size / 2);
    }
  }
}
Content from @app\src\main\java\io\github\sasori_256\town_planning\util\Constants.java:

Content from @app\src\main\java\io\github\sasori_256\town_planning\util\ResourceLoader.java:
package io.github.sasori_256.town_planning.util;
Content from @app\src\main\java\io\github\sasori_256\town_planning\view\GameWindow.java:

--- End of content ---

---

âœ¨ ## MODEL

`app/src/main/java/io/github/sasori_256/town_planning/` ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’åˆ†æã—ã¾ã—ãŸã€‚

ç¾åœ¨ã®ã€Œå…¨ã¦ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ `GameObject` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã€å±æ€§ã‚’ `Map<String, Object>` ã§ç®¡ç†ã™ã‚‹ã€æ–¹å¼ã‹ã‚‰ã€**ã€Œç¶™æ‰¿ã‚’ç”¨ã„ãŸã‚¯ãƒ©ã‚¹éšå±¤ + Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã€** ã¸ç§»è¡Œã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ¡ˆã‚’æç¤ºã—ã¾ã™ã€‚

ã“ã®å¤‰æ›´ã«ã‚ˆã‚Šã€å‹å®‰å…¨æ€§ã€ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ã€ãŠã‚ˆã³UIå®Ÿè£…ã®å®¹æ˜“ã•ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™ã€‚

---

### ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°æ–¹é‡

1.  **ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ã‚¯ãƒ©ã‚¹åŒ– (Inheritance)**
    *   `GameObject` ã‚’ **æŠ½è±¡ã‚¯ãƒ©ã‚¹ (`abstract class`)** ã«å¤‰æ›´ã—ã€å…±é€šã® `attributes` ãƒãƒƒãƒ—ã‚’å»ƒæ­¢ï¼ˆã¾ãŸã¯ç¸®å°ï¼‰ã—ã¾ã™ã€‚
    *   å…·è±¡ã‚¯ãƒ©ã‚¹ `Resident`, `Building`, `DisasterEntity` ã‚’ä½œæˆã—ã€é©åˆ‡ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`age`, `durability` ãªã©ï¼‰ã‚’æŒãŸã›ã¾ã™ã€‚
2.  **Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®é©ç”¨**
    *   `GameAction` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã—ã€`BuildingType`, `DisasterType` ã«å®Ÿè£…ã•ã›ã¾ã™ã€‚
3.  **Strategyã®æ•´ç†**
    *   Strategyã¯ã€Œãƒ‡ãƒ¼ã‚¿ä¿æŒã€ã®å½¹å‰²ã‹ã‚‰è§£æ”¾ã•ã‚Œã€ã€Œç´”ç²‹ãªãƒ­ã‚¸ãƒƒã‚¯ï¼ˆç§»å‹•ã€æç”»ï¼‰ã€ã«å°‚å¿µã•ã›ã¾ã™ã€‚
    *   ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ `model.strategy.resident` ç­‰ã«æ•´ç†ã—ã¾ã™ã€‚

---

### 1. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆã®å¤‰æ›´æ¡ˆ

ã¾ãšã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æ§‹æˆã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«æ•´ç†ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™ã€‚

```text
model/
  â”œâ”€â”€ entity/                <-- [New] å…·è±¡ã‚¯ãƒ©ã‚¹ç½®ãå ´
  â”‚   â”œâ”€â”€ Resident.java
  â”‚   â”œâ”€â”€ Building.java
  â”‚   â””â”€â”€ DisasterEntity.java
  â”œâ”€â”€ strategy/
  â”‚   â”œâ”€â”€ resident/          <-- ä½æ°‘ç”¨
  â”‚   â”œâ”€â”€ building/          <-- å»ºç‰©ç”¨
  â”‚   â”œâ”€â”€ disaster/          <-- ç½å®³ç”¨
  â”‚   â””â”€â”€ common/            <-- å…±é€š (SimpleRenderStrategyãªã©)
  â””â”€â”€ GameAction.java        <-- [New] Command I/F
```

---

### 2. ã‚³ãƒ¼ãƒ‰ã®æ›¸ãæ›ãˆæ¡ˆ

#### A. åŸºåº•ã‚¯ãƒ©ã‚¹ã®å¤‰æ›´ (`core/GameObject.java`)

`Map` ã‚’å‰Šé™¤ã—ã€ç´”ç²‹ãªåŸºåº•ã‚¯ãƒ©ã‚¹ã«ã—ã¾ã™ã€‚

```java
package io.github.sasori_256.town_planning.core;

import java.awt.Graphics2D;
import java.awt.geom.Point2D;
import java.util.UUID;
import io.github.sasori_256.town_planning.core.strategy.RenderStrategy;
import io.github.sasori_256.town_planning.core.strategy.UpdateStrategy;

public abstract class GameObject implements GameEntity {
    protected final String id;
    protected Point2D position;
    
    // Strategyã¯ç¶­æŒï¼ˆæŒ¯ã‚‹èˆã„ã®åˆ‡ã‚Šæ›¿ãˆã«ã¯ä¾ç„¶ã¨ã—ã¦æœ‰ç”¨ï¼‰
    protected UpdateStrategy updateStrategy;
    protected RenderStrategy renderStrategy;

    public GameObject(Point2D position) {
        this.id = UUID.randomUUID().toString();
        this.position = position;
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä½•ã‚‚ã—ãªã„
        this.updateStrategy = (ctx, self) -> {};
        this.renderStrategy = (g, self) -> {};
    }

    // å…±é€šãƒ¡ã‚½ãƒƒãƒ‰
    @Override public String getId() { return id; }
    @Override public Point2D getPosition() { return position; }
    public void setPosition(Point2D position) { this.position = position; }

    public void setUpdateStrategy(UpdateStrategy strategy) { this.updateStrategy = strategy; }
    public void setRenderStrategy(RenderStrategy strategy) { this.renderStrategy = strategy; }

    public void update(GameContext context) {
        updateStrategy.update(context, this);
    }

    public void render(Graphics2D g) {
        renderStrategy.render(g, this);
    }
}
```

#### B. å…·è±¡ã‚¯ãƒ©ã‚¹ã®å®Ÿè£… (`model/entity/`)

**Resident.java (ä½æ°‘)**
```java
package io.github.sasori_256.town_planning.model.entity;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.model.ResidentType;
import java.awt.geom.Point2D;

public class Resident extends GameObject {
    private ResidentType type;
    private double age;
    private final double maxAge;
    private int faith;
    private boolean isDead;

    public Resident(Point2D position, ResidentType type, double maxAge) {
        super(position);
        this.type = type;
        this.age = 0.0;
        this.maxAge = maxAge;
        this.faith = 10;
        this.isDead = false;
    }

    // Getters / Setters (å‹å®‰å…¨!)
    public void growOld(double amount) { this.age += amount; }
    public double getAge() { return age; }
    public boolean isDead() { return isDead; }
    public void setDead(boolean dead) { this.isDead = dead; }
    // ...
}
```

**Building.java (å»ºç‰©)**
```java
package io.github.sasori_256.town_planning.model.entity;

import io.github.sasori_256.town_planning.core.GameObject;
import io.github.sasori_256.town_planning.model.BuildingType;
import java.awt.geom.Point2D;

public class Building extends GameObject {
    private final BuildingType type;
    private int currentDurability;
    private int currentPopulation; // åå®¹ä¸­ã®äººæ•°ãªã©

    public Building(Point2D position, BuildingType type) {
        super(position);
        this.type = type;
        this.currentDurability = 100; // type.getMaxDurability() ãªã©ã‹ã‚‰å–å¾—
    }

    public BuildingType getType() { return type; }
    public void addPopulation(int count) { this.currentPopulation += count; }
    // ...
}
```

#### C. Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®å°å…¥ (`model/GameAction.java` & Enums)

**GameAction.java**
```java
package io.github.sasori_256.town_planning.model;

import io.github.sasori_256.town_planning.core.GameContext; // ã¾ãŸã¯ GameModel
import java.awt.geom.Point2D;

public interface GameAction {
    String getName();
    int getCost();
    // å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰: GameModelã‚’å—ã‘å–ã‚Šã€å¤‰æ›´ã‚’åŠ ãˆã‚‹
    boolean execute(GameModel model, Point2D targetPos);
}
```

**BuildingType.java (æ”¹ä¿®)**
```java
public enum BuildingType implements GameAction {
    HOUSE("ä½å±…", ...),
    // ...
    ;
    // ... ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾© ...

    @Override
    public boolean execute(GameModel model, Point2D targetPos) {
        return model.constructBuilding(this, targetPos);
    }
}
```

**DisasterType.java (æ”¹ä¿®)**
```java
public enum DisasterType implements GameAction {
    METEOR("éš•çŸ³", ...),
    // ...
    ;
    
    @Override
    public boolean execute(GameModel model, Point2D targetPos) {
        // ç½å®³ç™ºç”Ÿãƒ­ã‚¸ãƒƒã‚¯å‘¼ã³å‡ºã—
        return model.triggerDisaster(this, targetPos);
    }
}
```

#### D. Strategyã®é©å¿œ (`model/strategy/resident/ResidentLifeCycleStrategy.java`)

ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚„ã‚­ãƒ£ã‚¹ãƒˆã‚’ä½¿ã£ã¦ã€å‹å®‰å…¨ã«ãƒ‡ãƒ¼ã‚¿ã¸ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚

```java
public class ResidentLifeCycleStrategy implements UpdateStrategy {
    @Override
    public void update(GameContext context, GameObject self) {
        // å®‰å…¨ãªã‚­ãƒ£ã‚¹ãƒˆ
        if (!(self instanceof Resident)) return;
        Resident resident = (Resident) self;

        if (resident.isDead()) return;

        double dt = context.getDeltaTime();
        resident.growOld(dt * 0.1); // å°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã¹ã‚‹ï¼

        if (resident.getAge() >= resident.getMaxAge()) {
            die(context, resident);
        }
    }
    // ...
}
```

---

### 3. æ¬¡ã«è¡Œã†ã¹ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³

ã“ã®ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã‚’ä¸€æ°—ã«è¡Œã†ã¨ä¸€æ™‚çš„ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒå¤§é‡ã«å‡ºã¾ã™ã€‚ä»¥ä¸‹ã®æ‰‹é †ã§é€²ã‚ã‚‹ã®ãŒå®‰å…¨ã§ã™ã€‚

1.  **å…·è±¡ã‚¯ãƒ©ã‚¹ã®ä½œæˆ:** `Building`, `Resident` ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹ï¼ˆã¾ã  `GameObject` ã¯æŠ½è±¡åŒ–ã—ãªã„ï¼‰ã€‚
2.  **Commandã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å°å…¥:** `GameAction` ã‚’ä½œã‚Šã€Enumã« `implements` ã•ã›ã‚‹ã€‚
3.  **Modelã®ä¿®æ­£:** `GameModel.constructBuilding` ãªã©ã§ `new GameObject()` ã—ã¦ã„ã‚‹éƒ¨åˆ†ã‚’ `new Building()` ã«å¤‰ãˆã‚‹ã€‚
4.  **Strategyã®ä¿®æ­£:** `getAttribute` ã‚’ä½¿ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚’ã€ã‚­ãƒ£ã‚¹ãƒˆ + ã‚²ãƒƒã‚¿ãƒ¼ (`resident.getAge()`) ã«æ›¸ãæ›ãˆã‚‹ã€‚
5.  **GameObjectã®æŠ½è±¡åŒ–:** æœ€å¾Œã« `GameObject` ã‚’ `abstract` ã«ã—ã€`attributes` ãƒãƒƒãƒ—ã‚’å‰Šé™¤ã™ã‚‹ã€‚

ã©ã®ã‚¹ãƒ†ãƒƒãƒ—ã‹ã‚‰ç€æ‰‹ã—ã¾ã™ã‹ï¼Ÿ
ã¾ãšã¯ **ã€Œãƒ¢ãƒ‡ãƒ«éšå±¤ã®å®šç¾©ï¼ˆStep 1: Resident, Buildingã‚¯ãƒ©ã‚¹ã®ä½œæˆï¼‰ã€** ã‹ã‚‰å§‹ã‚ã‚‹ã®ãŒä¸€ç•ªã‚¹ãƒ ãƒ¼ã‚ºã§ã™ã€‚

---

ğŸ§‘â€ğŸ’» ## USER

å„å¼•æ•°ã§selfãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹é–¢æ•°ãŒã‚ã‚‹ã®ã¯ãªãœã§ã™ã‹ï¼Ÿthisã¨ã¯é•ã†ã®ã§ã™ã‹ï¼Ÿ

---

âœ¨ ## MODEL

ãã‚Œã¯ `UpdateStrategy` ã‚„ `RenderStrategy` ãªã©ã® **Strategyï¼ˆæˆ¦ç•¥ï¼‰ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©** ã«ç”±æ¥ã—ã¾ã™ã€‚

```java
// ä¾‹: UpdateStrategy
public interface UpdateStrategy {
    // èª°ã‚’(self)æ›´æ–°ã™ã‚‹ã‹ã‚’å—ã‘å–ã‚‹
    void update(GameContext context, GameObject self);
}
```

### ãªãœ `self` ãŒå¼•æ•°ã«å¿…è¦ãªã®ã‹ï¼Ÿ

1.  **Strategyã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãã®ã‚‚ã®ã§ã¯ãªã„ï¼ˆåˆ†é›¢ã•ã‚Œã¦ã„ã‚‹ï¼‰ã‹ã‚‰**
    *   `RandomMoveStrategy` ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä¸­ã§ã® `this` ã¯ã€**ã€Œæˆ¦ç•¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè‡ªèº«ï¼ˆRandomMoveStrategyï¼‰ã€** ã‚’æŒ‡ã—ã¾ã™ã€‚
    *   ã—ã‹ã—ã€ç§»å‹•ã•ã›ãŸã„ã®ã¯ **ã€Œæˆ¦ç•¥ã‚’ä½¿ã£ã¦ã„ã‚‹ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆResidentãªã©ï¼‰ã€** ã§ã™ã€‚
    *   Javaã®ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã€å‘¼ã³å‡ºã—å…ƒï¼ˆCallerï¼‰ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«è‡ªå‹•çš„ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã¯ãªã„ãŸã‚ã€å¼•æ•°ã¨ã—ã¦æ˜ç¤ºçš„ã«æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

2.  **Strategyã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã„å›ã™ãŸã‚ï¼ˆãƒ¡ãƒ¢ãƒªç¯€ç´„ï¼‰**
    *   ã‚‚ã— `self` ã‚’å¼•æ•°ã§æ¸¡ã•ãšã€Strategyã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§ `GameObject` ã‚’ä¿æŒã•ã›ãŸã¨ã—ã¾ã™ã€‚
        ```java
        // ãƒ€ãƒ¡ãªä¾‹: 1å¯¾1ã«ãªã£ã¦ã—ã¾ã†
        class RandomMoveStrategy {
            GameObject owner;
            public RandomMoveStrategy(GameObject owner) { this.owner = owner; }
            public void update() { owner.move(...); }
        }
        ```
    *   ã“ã†ã™ã‚‹ã¨ã€ä½æ°‘ãŒ1000äººã„ãŸã‚‰ã€Strategyã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚1000å€‹å¿…è¦ã«ãªã‚Šã¾ã™ã€‚
    *   ä¸€æ–¹ã€å¼•æ•°ã§ `self` ã‚’æ¸¡ã™è¨­è¨ˆãªã‚‰ã€**ãŸã£ãŸ1ã¤ã®Strategyã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³çš„ãªä½¿ã„æ–¹ï¼‰ã‚’1000äººã®ä½æ°‘ã§å…±æœ‰ã§ãã¾ã™**ã€‚
        *   ï¼ˆâ€»ãŸã ã—ã€Strategyè‡ªä½“ãŒã€Œå†…éƒ¨çŠ¶æ…‹ï¼ˆã‚¿ã‚¤ãƒãƒ¼ãªã©ï¼‰ã€ã‚’æŒã¤å ´åˆã¯å…±æœ‰ã§ãã¾ã›ã‚“ã€‚ç¾åœ¨ã® `RandomMoveStrategy` ã¯ `moveTimer` ã¨ã„ã†å†…éƒ¨çŠ¶æ…‹ã‚’æŒã£ã¦ã„ã‚‹ã®ã§ã€å®Ÿéš›ã«ã¯å…±æœ‰ã§ãã¦ãŠã‚‰ãšã€1äººã«ã¤ã1å€‹ç”Ÿæˆã—ã¦ã„ã‚‹ã¯ãšã§ã™ã€‚ã‚‚ã—å…±æœ‰ã™ã‚‹ãªã‚‰ã€ã‚¿ã‚¤ãƒãƒ¼ã‚‚ `self`ï¼ˆä½æ°‘å´ï¼‰ã«æŒãŸã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼‰

### ã¾ã¨ã‚

*   `this`: Strategyã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹è‡ªèº«ã€‚
*   `self` (å¼•æ•°): ãã®Strategyã‚’åˆ©ç”¨ã—ã¦æŒ¯ã‚‹èˆã„ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ `GameObject`ï¼ˆã¾ãŸã¯ `Resident` / `Building`ï¼‰ã€‚

ã‚‚ã— `Resident` ã‚¯ãƒ©ã‚¹ã®ä¸­ã«ç›´æ¥ `update()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›¸ãå ´åˆï¼ˆStrategyã‚’ä½¿ã‚ãªã„å ´åˆï¼‰ã¯ã€`this` ãŒä½æ°‘ãã®ã‚‚ã®ã‚’æŒ‡ã™ã®ã§ `self` å¼•æ•°ã¯ä¸è¦ã«ãªã‚Šã¾ã™ã€‚Strategyãƒ‘ã‚¿ãƒ¼ãƒ³ç‰¹æœ‰ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã§ã™ã€‚